## Набор ключей (HashSet)

В языке Руби существует возможность вывести список ключей в каком-либо хеше. Работает этот метод довольно предсказуемо:

{line-numbers: false}
```ruby
$ pry
> hh = {}
=> {}
> hh[:red] = 'ff0000'
=> "ff0000"
> hh[:green] = '00ff00'
=> "00ff00"
> hh[:blue] = '0000ff'
=> "0000ff"
> hh.keys
=> [:red, :green, :blue]
```

Выше мы определили хеш с ключом типа *Symbol* и значением типа *String*. К слову, строковые значения — это общепринятое трехбайтное (в виде строки) обозначение цветов RGB, где первый байт отвечает за R(ed) — красный, второй — за G(reen) — зеленый, третий — за (B)lue — синий.

Получение списка ключей — не самая часто встречающаяся операция. Однако иногда возникает необходимость использовать только ключи в структуре данных «хеш». Это можно сделать через хеш, задавая любые значения (например, `true`), но есть специальная структура данных, которая содержит только ключи (без значений). Она называется `HashSet` (в Руби просто `Set`):

> (англ.) Set implements a collection of unordered values with no duplicates.

> (по-русски) Set представляет (реализует) собой коллекцию неупорядоченных неповторяющихся значений (то есть без дубликатов).

`Set` в переводе с английского языка — это набор, множество. То есть это просто набор каких-то данных, объединенных каким-то признаком.

Напишем небольшую программу для демонстрации структуры данных `HashSet`: есть предложение в нижнем регистре, нужно определить, все ли буквы английского языка используются в этом предложении. Известно, что предложение «quick brown fox jumps over the lazy dog» использует все буквы английского языка, поэтому его применяют для визуального тестирования шрифтов. А вот в «brown fox jumps over the lazy dog» (без слова quick) нет буквы `q`.

Нам нужно написать метод, который будет возвращать `true`, если в предложении содержатся все буквы, и `false`, если каких-то букв не хватает. Как мы могли бы написать эту программу?

Подход простой: делаем итерацию по каждому символу, если это не пробел, то добавляем в структуру данных «хеш». Так как в хеше не может быть дублированных значений, то максимальное количество ключей в хеше — 26 (количество букв английского алфавита). Если количество букв 26, то все буквы были использованы.

Что не так с обычным хешем в этой задаче? То, что, добавляя в хеш, мы должны указывать какое-то значение:

{line-numbers: false}
```ruby
hh[letter] = true
``` 

Мы можем указать `true`, `false`, любую строку — это совершенно не важно, этот объект не несет никакой смысловой нагрузки. Поэтому хорошо бы иметь хеш без значений, чтобы можно было сэкономить память и, самое главное, показать намерение — «значение нам не важно». В этом случае идеально подходит структура данных `HashSet`. Код программы может выглядеть следующим образом:

{caption: "Узнать, все ли буквы английского алфавита используются в данном предложении"}
```ruby
# импортируем пространство имен, т.к. set
# не определен в пространстве имен по умолчанию
require 'set'

# наш метод, который принимает строку
def f(str)
  # инициализируем set
  set = Set.new

  # итерация по каждому символу в строке
  str.each_char do |c|
    # только если символ между a и z (игнорируем пробелы и все остальное)
    if c >= 'a' && c <= 'z'
      # добавляем в set
      set.add(c)
    end
  end

  # результат выражения true, если есть все английские буквы в наборе
  set.size == 26
end

# выведет true, т.к. в этом предложении используются все буквы англ. алфавита
puts f('quick brown fox jumps over the lazy dog')
```

Вопрос «чем отличается `Hash` от `HashSet`» часто можно встретить на интервью. Незнание этих деталей не говорит о том, что вы не можете программировать. Но знание говорит о том, что у вас есть опыт в программировании и вы понимаете некоторые тонкости.

К слову, одна из ошибок, которую можно было бы сделать в этом задании, — разбить строку на символы методом `split`:

{line-numbers: false}
```ruby
> "quick brown fox jumps over the lazy dog".split('')
=> ["q", "u", "i", "c", "k", " ", "b", "r", "o", "w", "n", " ", "f", "o", "x", " ", "j", "u", "m", "p", "s", " ", "o", "v", "e", "r", " ", "t", "h", "e", " ", "l", "a", "z", "y", " ", "d", "o", "g"]
```

В этом случае произошло бы выделение дополнительной памяти. Представьте, что строка имеет размер в несколько гигабайт. Зачем формировать массив и расходовать память, когда можно просто воспользоваться итерацией по символам средствами класса *String*?

Другая возможная ошибка в этом упражнении — итерация строки до конца. Если строка довольно большая, а распределение символов равномерно, то вероятность того, что все символы встретятся где-то в начале, очень высока. Поэтому проверка на размер `HashSet` довольно полезна и в теории должна сэкономить вычислительные ресурсы.

X> ## Задание 1
X> В программе выше допущена ошибка, которая приведет к большим расходам вычислительных ресурсов на больших строках. Сможете ли вы ее увидеть?
>
X> ## Задание 2
X> После того как вы прочитали эту главу, попробуйте потренироваться и написать эту программу самостоятельно, не подсматривая в книгу.
