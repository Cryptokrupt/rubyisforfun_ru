## Размышления о массивах в Ruby

Язык Руби несомненно предоставляет широкий API для работы с массивами. Однако в каждом программном продукте есть недочёты и т.н. `areas of improvement`. Мы не говорим про баги, и эти размышления скорее про `Principle of a least surprise` — принцип наименьшего сюрприза, ключевая философия языка. До каких пределов действует этот принцип?

Давайте сравним некоторые методы для работы с массивами в языке Python и Ruby на следующих двух задачах:

* для массива чисел (например, 11, 22, 33, 44, 55) вернуть все элементы, кроме первого;
* для массива чисел вернуть все элементы, кроме последнего.

Сможет ли программист элегантно сделать это на языке Руби? Давайте попробуем решить первую задачу. Пожалуй, наиболее элегантный способ — это метод `drop`:

{line-numbers: false}
```ruby
arr = [11, 22, 33, 44, 55]
arr2 = arr.drop(1)
puts arr2.inspect
```

Вывод этой программы:

{line-numbers: false}
```
[22, 33, 44, 55]
```

Какие ещё способы вы можете предложить? Пожалуй, вот такой способ может сработать:

{line-numbers: false}
```ruby
arr2 = arr[1..-1]
```

Синтаксис говорит буквально следующее: берем элементы от индекса 1 и до конца (конец обозначается минус 1).

Вроде бы все понятно, но вам не кажется, что метод `drop` немного странный? Почему он удаляет элемент в начале массива? Кто-то скажет, что для удаления элемента в конце массива можно использовать метод `pop`. И это так, обязательно попробуйте это в вашем REPL. Но можете ли вы сказать, в чем принципиальное отличие `drop` от `pop`?

Метод `drop` возвращает массив, а метод `pop` возвращает элемент массива. Сравните два вывода в своем REPL. Метод `drop` работает в начале массива:

{line-numbers: false}
```ruby
arr = [11, 22, 33, 44, 55]
arr.drop(1) # выдаёт [22, 33, 44, 55]
```

И метод `pop`, который работает с концом массива:

{line-numbers: false}
```ruby
arr = [11, 22, 33, 44, 55]
arr.pop # выдаёт 55
```
 
Ну ладно, скажет читатель, воспользуемся магией Руби, чтобы вывод был одинаковым:

{line-numbers: false}
```ruby
arr = [11, 22, 33, 44, 55]
arr.tap(&:pop) # выдаёт [11, 22, 33, 44]
```

Ура! Но что-то не так. Можете ли вы догадаться, что именно? Мало того, что метод `drop` работает в начале массива (по мнению авторов, это не совсем не понятно), так ещё и метод `pop` меняет состояние системы, т.е. исходного массива. В то время как `drop` не меняет это состояние.

Чтобы реализовать что-то похожее на `drop` только в конце, можно воспользоваться чем-то вроде `take(arr.size - 1)`, курсивом ниже приводится вывод REPL:

{line-numbers: false}
```ruby
arr = [11, 22, 33, 44, 55]
arr.take(arr.size - 1)
 => [11, 22, 33, 44]
arr
 => [11, 22, 33, 44, 55]
```

Ура! Состояние не поменялось. Другими словами, для решения этой задачи в Руби существует несколько способов:

* `arr.drop(1)` — для того чтобы вернуть массив без первого элемента;
* `arr[1..-1]` — альтернативный способ;
* `arr.take(arr.size - 1)` — чтобы вернуть массив без последнего элемента;
* `arr[0..-2]` — альтернативный способ.

Подождите, подождите! Почему это в последнем случае у нас минус 2? Because we can! В Руби существует множество способов сделать одну и ту же задачу.

А что, если сравнить Руби с другими языками? Вот как выглядит вывод в языке Python:

{line-numbers: false}
```python
$ python

>>> arr = [11, 22, 33, 44, 55]
>>> arr[1:]
[22, 33, 44, 55]
>>> arr[:-1]
[11, 22, 33, 44]
```

Довольно понятно и наглядно. Вот бы и в Руби так было! Сравните, насколько просто работать с массивами в Python, если нам надо вернуть `подмассивы` (они называются `slice` — «срез») без двух элементов:

{line-numbers: false}
```
>>> arr[2:]
[33, 44, 55]
>>> arr[:-2]
[11, 22, 33]
```


X> ## Задание 1
X> Попробуйте все эти методы самостоятельно.
>
X> ## Задание 2
X> Создайте массив из пяти элементов и попробуйте вернуть массивы без первых двух элементов и без последних двух элементов. Ваш код не должен изменять состояние исходного массива.
