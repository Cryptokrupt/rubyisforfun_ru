## Битва роботов

Для закрепления материала давайте напишем простейшую игру «битва роботов». Возьмем 20 роботов и разделим их на 2 команды, в каждой команде по 10. Каждую команду будет представлять отдельный массив размером 10. Ячейка массива может принимать два значения:

* Ноль, `0` — когда робот уничтожен
* Единица, `1` — когда робот еще жив

Объявим два массива. Единица говорит о том, что мы объявляем массивы с живыми роботами:

{line-numbers: false}
```ruby
arr1 = Array.new(10, 1)
arr2 = Array.new(10, 1)
```

Каждые команды будут стрелять по-очереди. Определимся с термином «стрелять», что это значит? Если ноль в массиве это уничтоженный робот, а единица — живой, то стрелять значит «изменить значение с единицы на ноль для определенной ячейки массива». Но как мы будем определять какую ячейку менять? Тут есть два варианта:

* Менять ячейку подряд. Т.е. сначала уничтожаем первого робота во второй команде (первая команда делает ход), потом первого робота в первой и т.д. Побеждает всегда тот, кто первый начал. Это не интересно.
* Намного интереснее выбирать `индекс` от 0 до 9 каждый раз случайно. Случайность не гарантирует того, что `индекс` не повторится. Поэтому одна команда может «стрельнуть» по одному и тому же месту. Например, через пять ходов вторая команда бьет в пятую ячейку, а выстрел по ней уже был до этого. Следовательно, выстрел не попал в цель, ячейка уже равна нулю, и количество убитых роботов не изменилось. Т.е. результат сражения заранее не гарантирован и зависит от везения.

Выберем второй вариант. Определять случайный индекс от 0 до 9 мы уже умеем:

{line-numbers: false}
```ruby
i = rand(0..9)
```

Далее осталось только обратиться к ячейке массива и, если она равна единице, то присвоить ей значение ноль. А если ячейка уже равна нулю, значит выстрел по этому месту уже был:

{line-numbers: false}
```ruby
if arr[i] == 1
  arr[i] = 0
  puts "Робот по индексу #{i} убит"
else
  puts 'Промазали!'
end
```

Выигрывает та команда, в которой остался хотя бы один робот. Также было бы полезно узнать, сколько именно роботов осталось. Как же нам это сделать? Представим, что у нас есть массив:

{line-numbers: false}
```ruby
arr = [1, 0, 1, 0, 1, 1]
```

Как определить количество элементов, равных единице? Мы можем использовать уже знакомый нам метод `each`, делать сравнение и записывать результат в переменную:

{caption: "Подсчитать количество единиц в массиве, наивный способ"}
```ruby
arr = [1, 0, 1, 0, 1, 1]
x = 0
arr.each do |element|
  if element == 1
    x += 1
  end
end
puts "В массиве #{x} единиц"
```

Программа работает, но есть способ проще. Метод `count` класса *Array* (обязательно посмотрите документацию) делает то же самое, но выглядит намного проще:

{caption: "Подсчитайте количество единиц в массиве, передав блок методу count"}
```ruby
arr = [1, 0, 1, 0, 1, 1]
x = arr.count do |x|
  x == 1
end
puts "В массиве #{x} единиц"
```

Или более короткий способ записи:

{caption: "Однострочник для вычисления количества единиц в массиве путем передачи блока в метод count"}
```ruby
arr = [1, 0, 1, 0, 1, 1]
x = arr.count { |x| x == 1 }
puts "В массиве #{x} единиц"
```

На данном этапе у нас есть все, что нужно. Две команды роботов, стрелять будут по очереди, индекс выбирается случайно, проигрывает тот, у кого не осталось ни одного робота. Можно писать эту игру. Т.к. игра не требует ввода пользователя, мы будем на нее только смотреть.

X> ## Задание 
X> Напишите эту игру самостоятельно. Сравните свой результат с программой ниже. Внимание: есть вероятность, что у вас что-то не получится, в данном случае неважно, сможете ли вы написать эту программу или нет, важен процесс и работа над ошибками.

Код программы:

{line-numbers: false}
```ruby
###############################
# ОБЪЯВЛЯЕМ МАССИВЫ
###############################

# массив для первой команды
@arr1 = Array.new(10, 1)
# массив для второй команды
@arr2 = Array.new(10, 1)

###############################
# АТАКА
###############################

# Метод принимает массив для атаки
def attack(arr)
  sleep 1 # добавим sleep для красоты
  i = rand(0..9)
  if arr[i] == 1
    arr[i] = 0
    puts "Робот по индексу #{i} уничтожен"
  else
    puts "Промазали по индексу #{i}"
  end
  sleep 1 # еще один sleep для красоты вывода
end

###############################
# ПРОВЕРКА ПОБЕДЫ
###############################

def victory?
  robots_left1 = @arr1.count { |x| x == 1 }
  robots_left2 = @arr2.count { |x| x == 1 }

  if robots_left1 == 0
    puts "Команда 2 победила, в команде осталось #{robots_left2} роботов"
    return true
  end

  if robots_left2 == 0
    puts "Команда 1 победила, в команде осталось #{robots_left1} роботов"
    return true
  end

  false
end

###############################
# СТАТИСТИКА
###############################

def stats
  # количество живых роботов для первой и второй команды
  cnt1 = @arr1.count { |x| x == 1 }
  cnt2 = @arr2.count { |x| x == 1 }
  puts "1-ая команда: #{cnt1} роботов в строю"
  puts "2-ая команда: #{cnt2} роботов в строю"
end

###############################
# ГЛАВНЫЙ ЦИКЛ
###############################

loop do
  puts 'Первая команда наносит удар...'
  attack(@arr2)
  exit if victory?
  stats
  sleep 3
  puts # пустая строка

  puts 'Вторая команда наносит удар...'
  attack(@arr1)
  exit if victory?
  stats
  sleep 3
  puts # пустая строка
end
```

Результат работы программы:

{line-numbers: false}
```
Первая команда наносит удар...
Робот по индексу 2 уничтожен
1-ая команда: 10 роботов в строю
2-ая команда: 9 роботов в строю

Вторая команда наносит удар...
Робот по индексу 8 уничтожен
1-ая команда: 9 роботов в строю
2-ая команда: 9 роботов в строю

…

Первая команда наносит удар...
Робот по индексу 7 уничтожен
1-ая команда: 1 роботов в строю
2-ая команда: 2 роботов в строю

Вторая команда наносит удар...
Робот по индексу 2 уничтожен
Команда 2 победила, в команде осталось 2 роботов
```

X> ## Задание 1 
X> Чтобы статистика была более наглядной, добавьте в программу выше вывод двух массивов.
>
X> ## Задание 2
X> Вместо бинарного значения ноль или единица пусть каждый робот имеет уровень жизни, который выражается целым числом от 1 до 100 (в самом начале это значение должно быть установлено в 100). Пусть каждая атака отнимает случайную величину жизни у робота от 30 до 100. Если уровень жизни ниже или равен нулю, робот считается уничтоженным.