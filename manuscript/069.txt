## Передача опций в методы

Допустим, что нам нужно вызвать какой-то метод и передать ему несколько параметров. Например, пользователь выбрал определенное количество футбольных мячей, мячей для тенниса, и мячей для гольфа. Мы хотим написать метод, который считает общий вес. Это может быть сделано обычным способом:

{line-numbers: false}
```ruby
def total_weight(soccer_ball_count, tennis_ball_count, golf_ball_count)
  # ...
end
```

В этом случае вызов выглядел бы следующим образом:

{line-numbers: false}
```ruby
x = total_weight(3, 2, 1)
```

Три футбольных мяча, два мяча для тенниса, один для гольфа. Согласитесь, что когда мы смотрим на запись `total_weight(3, 2, 1)` не очень понятно, что именно означают эти параметры. Это мы знаем, что сначала идут футбольные мячи, потом должны идти мячи для тенниса, потом для гольфа. Но чтобы это понять другому программисту, нужно посмотреть на сам метод.

Это не очень удобно, поэтому некоторые IDE (Integrated Development Environment, редакторы кода, среды разработки) автоматически подсказывают что именно это за параметр. Например, такая функциональность есть в RubyMine. Однако, в силу динамической природы языка RubyMine не всегда может определить правильное название параметров. Да и многие руби программисты используют текстовые редакторы попроще. 

Поэтому многие программисты предпочитали передавать в методы хеш с параметрами:

{line-numbers: false}
```ruby
def total_weight(options)
  a = options[:soccer_ball_count]
  b = options[:tennis_ball_count]
  c = options[:golf_ball_count]
  puts a
  puts b
  puts c
  # ...
end

params = { soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1 }
x = total_weight(params)
```

Согласитесь, что код

{line-numbers: false}
```ruby
total_weight({ soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1 })
```

выглядит более понятным, чем просто `total_weight(3, 2, 1)`. Несмотря на то, что запись выше выглядит длиннее, у нее есть два преимущества.

Во-первых, точно видно какие параметры мы передаем, т.к. мы явно указываем названия этих параметров.

А во-вторых, порядок параметров в хеше не имеет значения. В случае с `total_weight(3, 2, 1)` нам нужно соблюдать порядок и всегда помнить: первый элемент это количество футбольных мячей и т.д. В случае с хешем можно указать обратный порядок и это не будет ошибкой:

{line-numbers: false}
```ruby
total_weight({ golf_ball_count: 1, tennis_ball_count: 2, soccer_ball_count: 3 })
```

Программа получается более наглядная, и нам не нужно помнить про порядок! Позднее синтаксис был упрощен, и теперь для вызова функции, которая принимает хеш с параметрами не нужно указывать фигурные скобки, метод все равно будет принимать хеш:

{line-numbers: false}
```ruby
total_weight(golf_ball_count: 1, tennis_ball_count: 2, soccer_ball_count: 3)
``` 

Теперь метод для подсчета веса можно переписать иначе:

{caption: "Рассчитать общий вес, принять опции в виде хэша"}
```ruby
def total_weight(options)
  a = options[:soccer_ball_count]
  b = options[:tennis_ball_count]
  c = options[:golf_ball_count]
  puts a
  puts b
  puts c
  # ...
end

x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
```

Но что будет, если мы вызовем этот метод вообще без каких-либо аргументов? По идее, метод должен вернуть ноль. Но мы получаем сообщение об ошибке:

> ArgumentError: wrong number of arguments (given 0, expected 1)

Руби нам говорит о том, что метод ожидает 1 параметр, а мы ничего не предоставили. С точки зрения бизнес-логики может показаться, что это правильно — «не нужно вызывать неправильно то, что что-то считает. Если хотите посчитать общий вес, то укажите сколько мячей или укажите явно — ноль мячей для футбола, ноль для тенниса, ноль для гольфа». Это кажется разумным, но давайте представим, что `total_weight` может вызываться и без параметров. В этом случае, например, метод должен возвращать вес пустой коробки (29 грамм). Что же нам делать?

Решение очень простое: сделать так, чтобы параметр `options` принимал какое-либо значение по-умолчанию. Например, пустой хеш. Если хеш будет пустой, то переменные `a, b, c` будут инициализированы значением `nil` и метод можно будет вызывать без параметров. Указать значение по-умолчанию можно в определении метода с помощью знака «равно»:

{line-numbers: false}
```ruby
def total_weight(options={})
...
```

Важное примечание: несмотря на то, что «равно с пробелами» выглядит нагляднее, в руби-сообществе существует два мнения по этому поводу. Раньше было принято использовать равно без пробелов (но только при определении параметров метода по-умолчанию). Сейчас чаще всего встречается «равно с пробелами».

В зависимости от предпочтений, которые существуют в вашей команде, инструмент статического анализа кода Rubocop может выдать предупреждение:

{line-numbers: false}
```ruby
# не рекомендуется указывать пробелы
def total_weight(options = {})
...
```

Код нашей программы полностью теперь выглядит так:

{caption: "Вычислить общий вес, принять параметры в виде хэша, где параметр параметров имеет значение по умолчанию"}
```ruby
def total_weight(options={})
  a = options[:soccer_ball_count]
  b = options[:tennis_ball_count]
  c = options[:golf_ball_count]
  puts a
  puts b
  puts c
  # ...
end

x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
```

Можно вызвать `total_weight` без параметров и не будет ошибки (попробуйте самостоятельно в `pry`). Давайте теперь перепишем эту программу, чтобы она на самом деле считала вес посылки вместе с коробкой:

{caption: "Рассчитайте общий вес в граммах, включая вес упаковочной коробки"}
```ruby
def total_weight(options={})
  a = options[:soccer_ball_count]
  b = options[:tennis_ball_count]
  c = options[:golf_ball_count]
  (a * 410) + (b * 58) + (c * 45) + 29
end

x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
```

Программа работает и правильно считает. 3 футбольных мяча, 2 теннисных и 1 мяч для гольфа все вместе весят 1420 грамм. Попробуем вызвать метод `total_weight` без параметров:

{line-numbers: false}
```
...
> total_weight
NoMethodError: undefined method '*' for nil:NilClass
```

О нет, ошибка! В чем же дело? Конечно, ведь если мы не указываем параметр, то его нет и в хеше. И когда мы пытаемся прочитать переменные `a, b, c`, то все они принимают значения nil. А `nil` нельзя умножать:

{line-numbers: false}
```
$ pry
> nil * 410
NoMethodError: undefined method '*' for nil:NilClass
```

Тут мы можем прибегнуть к хитрости и логическому оператору «или». Попробуйте догадаться, что выведет на экран программа:

{line-numbers: false}
```ruby
if nil || true
  puts 'Yay!'
end
``` 

Программа выведет «Yay!», потому что руби увидит `nil`, это выражение его не удовлетворит, потом встретит логический оператор «или» и решит вычислить то, что находится после этого логического оператора. А после находится `true`, и результат выражения `nil || true` равняется в итоге `true` (истина), которое передается оператору `if` (если). Получается конструкция «если истина, то вывести на экран Yay!».

Теперь попробуйте догадаться, чему будет равно значение переменной `x`:

{line-numbers: false}
```ruby
x = nil || 123
```

Правильный ответ: 123. Эту же хитрость мы можем применить и к переменным `a, b, c` следующим образом:

{line-numbers: false}
```ruby
  a = options[:soccer_ball_count] || 0
```

Другими словами, если значение в хеше `options` не указано (равно `nil`), то переменной `a` будет присвоено значение `0`.

Код программы целиком:

{caption: "Рассчитать общий вес и использовать значения по умолчанию"}
```ruby
def total_weight(options={})
  a = options[:soccer_ball_count] || 0
  b = options[:tennis_ball_count] || 0
  c = options[:golf_ball_count] || 0
  (a * 410) + (b * 58) + (c * 45) + 29
end

x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
```

Теперь метод `total_weight` работает без параметров и возвращает 29. Мы можем также передать один или несколько параметров:

{line-numbers: false}
```ruby
> total_weight(tennis_ball_count: 2, golf_ball_count: 1)
190
``` 

Получился работоспособный метод, который принимает хеш с параметрами, который выглядит понятно, и в который можно передать любое количество параметров. 

Представим теперь, что в технический отдел пришел директор продаж с новым требованием к нашей программе: «если пользователь не заказывает мячи для гольфа, мы даем ему один в подарок!» Это требование легко реализовать в нашей функции. Код метода получился бы таким:

```ruby
def total_weight(options={})
  a = options[:soccer_ball_count] || 0
  b = options[:tennis_ball_count] || 0
  c = options[:golf_ball_count] || 1
  (a * 410) + (b * 58) + (c * 45) + 29
end
```

Мы рассмотрели передачу опций в метод с помощью хешей. Этот способ широко используется, особенно когда количество параметров метода больше пяти. Похожие решения также существуют в других языках. 

X> ## Задание: 
X> Центр Управления Полетами поручил вам задание написать метод `launch` (от англ. «запуск»), который будет принимать набор опций в виде хеша и отправлять в космос астронавтов «Белку» и/или «Стрелку». Метод должен принимать следующие параметры:

* `angle` — угол запуска ракеты. Если не задан, то значение по-умолчанию равно 90 (градусов)
* `astronauts` — массив символов (`:belka`, `:strelka`), если не задан, то в космос нужно отправлять и Белку, и Стрелку.
* `delay` — количество секунд через которые запустить ракету, если не задано, то равно пяти

Метод должен вести подсчет оставшихся до запуска секунд (например: «Осталось секунд: 5 4 3 2 1»). После истечения задержки, метод должен выводить сообщение о том, какой астронавт (астронавты) запущены, а также под каким углом была запущена ракета. Метод может принимать любое количество параметров (ноль, один, два, три). Возможные варианты вызова метода:

* `launch`
* `launch(angle: 91)`
* `launch(delay: 3)`
* `launch(delay: 3, angle: 91)`
* `launch(astronauts: [:belka])`
* и т.д. 