## Обращение к массиву массивов

Существует небольшая хитрость для обращения к массиву массивов (также говорят «к двумерному массиву», к «2D array»). Хитрость заключается в том, что сначала нужно обратиться к строке (`row`), а потом к столбцу (`column`). Способ обращения к обычному массиву мы уже знаем. Для вывода значения используется следующая конструкция:

{line-numbers: false}
```ruby
puts arr[4]
```

Для присваивания мы просто используем оператор `=`:

{line-numbers: false}
```ruby
arr[4] = 123
```

Где 4 — это индекс массива. В случае с двумерным массивом обычно используются двойные квадратные скобки. Например, следующий код обновит в 5-ой строке 9-ый столбец:

{line-numbers: false}
```ruby
arr[4][8] = 123
```

Такой способ обращения может показаться непривычным для обычного человека, потому что человек привык сначала указывать столбец, потом строку; сначала `X`, потом `Y`. Но тем не менее, для доступа к массиву нам нужно сначала указывать индекс строки, а потом уже индекс столбца. Причем, ничто не мешает записать нам конструкцию присваивания иначе, она будет намного понятнее (правда, длиннее):

{line-numbers: false}
```ruby
row = arr[4] # Получить весь массив пятой строки в переменную
row[8] = 123 # Изменить девятую ячейку на 123
```

А вот так можно вывести значение девятого столбца в пятой строке (альтернативный способ):

{line-numbers: false}
```ruby
row = arr[4] # на этом этапе row уже будет одномерный (обычный) массив
column = row[8]
puts column
```

Конечно, альтернативным способом редко кто пользуется, ведь общепринятый `arr[4][8]` проще и короче. 

В зависимости от типа задачи и от приложения с которым вы работаете, может использоваться разная терминология, обозначающая строку и столбец. Рассмотрим наиболее часто встречающиеся:

* `row` — строка, `column` — столбец. Обращение к массиву: `arr[row][column]`. 
* `y` — строка, `x` — столбец. Обращение к массиву: `arr[y][x]`
* `j` — строка, `i` — столбец. Обращение к массиву: `arr[j][i]`

Обратите внимание, что название переменной для индекса — `i` (от слова `index`). Если у нас есть более одной переменной для индекса, берется следующая буква в алфавите (`j`, а если массив трехмерный, то `k`). Впрочем, эти правила не являются каким-то стандартом, а всего-лишь наблюдением авторов.

Попробуем создать двумерный массив и обойти (`to traverse`) его. Это элементарная задача, которая вам может встретиться на интервью: `2D array traversal`:

{caption: "Двумерный обход массива 3 на 3"}
```ruby
arr = [
  %w(a b c),
  %w(d e f),
  %w(g h i)  
]

0.upto(2) do |j|
  0.upto(2) do |i|
    print arr[j][i]
  end
end
```

Вывод программы:

{line-numbers: false}
```
abcdefghi
```

Вверху мы видим двойной цикл (иногда его называют «вложенный цикл», «double loop», если имеют в виду цикл по `i` — то «inner loop», «внутренний цикл»). Как же он работает? Мы уже знаем, что «цикл j» просто «проходит» по массиву. Он «не знает», что у нас массив массивов, поэтому это обычная итерация по элементам массива:

{line-numbers: false}
```
  %w(a b c)
  %w(d e f)
  %w(g h i)  
``` 

Просто каждый элемент — еще один массив. Поэтому мы имеем право по нему пройти обычным образом, как мы это уже делали. Можно также записать нашу программу немного иначе, помощью `each`:

{line-numbers: false}
```ruby
arr = [
  %w(a b c),
  %w(d e f),
  %w(g h i)  
]

arr.each do |row|
  row.each do |value|
    print value
  end
end
```

Разумеется, что сам массив можно записать без помощи `%w` (согласитесь, что читаемость этого подхода немного ниже?):

{line-numbers: false}
```
arr = [
  ['a', 'b', 'c'],
  ['d', 'e', 'f'],
  ['g', 'h', 'i']  
]
```

X> ## Задание 1 
X> Обойдите массив выше «вручную», без помощи циклов, крест-накрест, таким образом, чтобы вывести на экран строку `aeiceg` (подпрограмма займет 6 строк — по 1 строке для каждого элемента).
>
X> ## Задание 2
X> Cоздайте 2D массив размером 3 на 3. Каждый элемент будет иметь одинаковое значение (например, «something»). Сделайте так, чтобы каждый элемент массива был защищен от `upcase!`. Например, если мы вызовем `arr[2][2].upcase!`, этот вызов не изменит содержимое других ячеек массива. Проверьте свое задание в `pry`.
>
X> ## Задание 3 
X> К вам обратился предприниматель Джон Смит. Джон говорит, что его бизнес специализируется на создании телефонных номеров для рекламы. Они хотят подписать с вами контракт, но прежде хотелось бы убедиться, что вы хороший программист, можете работать с их требованиями, и доставлять качественное программное обеспечение. Они говорят: у нас есть номера телефонов с буквами. Например, для бизнеса по продаже матрасов существует номер «555-MATRESS», который транслируется в «555-628-7377». Когда наши клиенты набирают буквенный номер на клавиатуре телефона (см. картинку ниже), он транслируется в цифровой. Напишите программу, которая будет переводить (транслировать) слово без дефисов в телефонный номер. Сигнатура метода будет следующей:

```
def phone_to_number(phone)
  # ваш код тут...
end

puts phone_to_number('555MATRESS') # должно напечатать 5556287377
```

Иллюстрация телефонной клавиатуры:

{width: 80%}
![Клавиатура телефона](images/048-phone-keyboard.png)