## Наследование

> - Что такое наследование?
> - Быстрый способ разбогатеть!

Наследование это третий кит, на котором стоит объектно-ориентированное программирование после инкапсуляции и полиморфизма. Но в то же время, наследование — весьма противоречивый концепт. Существует множество мнений по этому поводу. Тем не менее, сначала мы рассмотрим возможность, которую нам предлагает язык руби, а потом поговорим о том, почему это плохо.

Давайте представим, что на поле с роботами и собаками мы захотели добавить еще одного игрока, человека (класс `Human`). Всего в игре получилось бы три типа: `Robot`, `Dog`, `Human`. Что сделал бы начинающий ООП-программист, знакомый с наследованием? Он бы сделал следующий трюк.

Очевидно, что есть методы `up`, `down`, `left`, `right` — которые выполняют какие-то действия. Очевидно, что есть методы `x`, `y` (переменные экземпляра `@x` и `@y`, но `attr_accessor` добавляет методы, которые называются `getter` и `setter`). Есть метод `label` — который для каждого типа разный. Методы `up`, `down`, `left`, `right` реализуют какую-то функциональность, которая почти всегда одинакова.

Другими словами, есть что-то повторяющееся, а есть что-то совершенно уникальное для каждого объекта (`label`). Пока наши методы `up`, `down`, `left`, `right` относительно простые — всего 1 строка и мы по сути копируем эти методы из объекта в объект:

{caption: "Три разных класса с похожей функциональностью"}
```ruby
class Robot
  def right
    self.x += 1
  end

  def left
    self.x -= 1
  end

  def up
    self.y += 1
  end

  def down
    self.y -= 1
  end
end

class Dog
  # ...

  def right
    self.x += 1
  end

  def down
    self.y -= 1
  end
end

class Human
  def right
    self.x += 1
  end

  def left
    self.x -= 1
  end

  def up
    self.y += 1
  end

  def down
    self.y -= 1
  end
end
``` 

Но что если каждый из этих методов будет по 10 строк или мы вдруг захотим что-нибудь улучшить (например, добавить координату «z», чтобы получить трехмерное поле)? Придется копировать этот код между всеми классами. И если возникнет какая-либо ошибка, придется исправлять сразу в трех местах.

Поэтому начинающий ООП-программист видит повторяющуюся функциональность и говорит: «Ага! Вот это повторяется! Почему бы нам не воспользоваться наследованием? Есть робот, у которого есть все нужные методы, так почему бы не "переиспользовать" (`reuse`, `share`) уже встречающуюся функциональность?»:

{caption: "То же, что и выше, но меньше кода из-за наследования"}
```ruby
class Robot
  attr_accessor :x, :y

  def initialize(options={})
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right
    self.x += 1
  end

  def left
    self.x -= 1
  end

  def up
    self.y += 1
  end

  def down
    self.y -= 1
  end

  def label
    '*'
  end
end

class Dog < Robot
  def up
  end

  def left
  end

  def label
    '@'
  end
end

class Human < Robot
  def label
    'H'
  end
end
```

Мы использовали символ `<`, который говорит о том, что Человек и Собака являются классами, производными от робота. Сам символ как бы подсказывает, что вся функциональность из робота «поступает» в человека и собаку: `class Human < Robot`, `class Dog < Robot`. Говорят «класс Human наследует функциональность класса Robot». 

{width: 55%}
![Диаграмма классов](images/078-diagram.png)

(Некоторые продвинутые IDE и редакторы кода могут самостоятельно рисовать подобные диаграммы).

После того, как классы определены таким образом, мы можем создавать экземпляры класса обычным способом:

{line-numbers: false}
```ruby
robot = Robot.new
human = Human.new
dog = Dog.new
```

В классе `Human` все методы, за исключением `label` являются реализацией из класса `Robot`. Но если вы посмотрите на код и диаграмму, то вы увидите, что в классе `Dog`, помимо `label`, реализованы свои собственные классы `up` и `left`. А все остальное также берется из класса `Robot`.  

Этот подход кажется гениальным! Посудите сами, класс `Dog` занимал 28 строк, а сейчас занимает 11. Класс `Human` мог бы занимать 28 строк, а занимает всего 5. Просто потому что мы воспользовались наследованием! Если мы применим наследование к нашему примеру программы, которую мы писали ранее, то программа будет прекрасно работать. Но, к сожалению, есть один неприятный момент.

Этот момент не технический. Другими словами, в техническом плане все прекрасно. Представьте, что к вам приходит коммерсант, который просит написать программу. Вы пишите программу, она работает и вы получаете деньги. Коммерсант не заглядывает в код, т.к. он не понимает, как этот код работает. Достаточно результата на экране.

Так пишется большинство программ, ведь деньги платит бизнес. А бизнесу важно, чтобы работали бизнес-процессы. Чтобы люди, например, развлекались глядя на то, как четыре собаки хотят пересечь поле с роботами (и, возможно, делали ставки). Бизнесу важно, чтобы пользователи вводили значения в поля и формы и на выходе выдавался правильный конечный результат. Бизнесу не важно что именно происходит внутри и как именно работает программа, работа программы — всегда (или почти всегда) на совести программиста.

Но с точки зрения профессиональной разработки наша программа написана неправильно. Неправильно, потому что объектно-ориентированное программирование очень просто использовать не по-назначению. Это является ошибкой многих программистов, и вообще есть [мнение](https://www.yegor256.com/2016/09/13/inheritance-is-procedural.html), что «наследование» в объектно-ориентированном программировании не должно существовать.

Давайте разберемся что же в нашей программе неправильно. Если вкратце — то мы позаимствовали функциональность робота, но сделали это без уважения. Определение наследования из [Википедии](https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) — настоятельно рекомендуется ознакомиться с этой статьей, при возможности прочитать [английскую версию](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)):

> Наследование — концепция согласно которой тип данных может наследовать данные и функциональность некоторого существующего типа, способствуя повторному использованию компонентов программного обеспечения.

Вроде бы все правильно. Есть тип данных `Human`, есть тип данных `Dog`. Есть существующий тип `Robot`. Мы использовали наследование и способствовали повторному использованию кода, так в чем же дело? Для этого обратимся к определению слова «Inherit» (наследовать) в Оксфордском словаре:

> Derive (a quality, characteristic, or predisposition) genetically from one's parents or ancestors.
> Перевод: Получать (качество, характеристику, предрасположенность) генетически от какого-либо родителя или предка.

Дело в том, что у человека с роботом и у собаки с роботом нет ничего общего. Они не могут получить характеристики робота генетически. То, что мы сделали — генная инженерия, мы просто скопировали функциональность и «притворились», что робот — это предок человека и собаки. Такого ведь не бывает в реальном мире? Более того, методы робота становятся основной для двух остальных классов, и, следовательно, при изменении робота нам нужно думать о том, чтобы случайно «не повредить» человека и собаку.

Робот уже не живой организм. Вроде бы он независимый и у него нет ничего общего с человеком и собакой, но нам нужно держать в голове мысль о том, что у робота существует два потомка. И вся эта сложность только из-за того, чтобы избежать дублирования кода и сделать нашу программу короче!

Другими словами, мы выбрали неправильную абстракцию. Это самая часто встречающаяся ошибка объектно-ориентированных программистов. Конечно, ошибки делать всегда хорошо, мы на них учимся. Но чтобы увидеть ошибку в объектно-ориентированном проектировании, требуется опыт. А само объектно-ориентированное программирование требует большей силы мысли. 

Начинающему программисту очень просто попасть в ловушку и выбрать неправильную абстракцию. Сэнди Мэтз [говорит](https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction) о том, что дублирование кода обходится значительно дешевле (в будущем), чем неверная абстракция. И если вы не уверены в выбранной абстракции, то лучше продублировать код. Получается, что все это наследование, которое мы только что разобрали, не нужно и можно было просто обойтись дублированием кода?

Да, можно было просто обойтись дублированием кода. Это то, с чем стараются бороться некоторые команды любыми средствами. Однако, дублирование кода не всегда плохо. Скажем, в тестировании программ (разбирается дальше в этой книге) дублирование кода не является большой проблемой. Если мы говорим не о тестах, а об обычных программах, то в некоторых случаях тоже лучше продублировать код, чем пытаться от него избавиться (если вы упоминаете об этом на интервью, то вашу точку зрения нужно будет аргументированно подтвердить).

В руби существует отдельный механизм для дублирования кода — модули. Т.е. первый способ избавления от неверной абстракции может состоять в создании и использовании модуля.
