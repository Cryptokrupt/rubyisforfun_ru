## Другие объекты в качестве значений

Мы уже разобрались с тем, что хеш — это набор `key-value pairs` (пара ключ-значение), где `key` — это обычно *Symbol* или *String*, а `value` — это объект. В нашем примере в качестве объекта всегда было число. Но мы также можем использовать объекты любого другого типа в качестве значений, включая строки, массивы и даже сами хеши.

То же самое и с массивами. В качестве элементов массива могут быть числа, строки, сами массивы (в этом случае получаются двумерные, многомерные массивы), а также и хеши. И эти хеши могут содержать в себе другие хеши или массивы массивов. Иными словами, при комбинации массивов и хешей получается уникальная структура данных, которую называют JSON (JavaScript Object Notation — мы уже говорили о том, что хеш в JavaScript часто называют `object`). Несмотря на то что это название изначально появилось в JavaScript, в Руби оно тоже широко используется.

Вот как может выглядеть простая комбинация массива и хеша:

{line-numbers: false}
```ruby
obj = {
  soccer_ball: { weight: 410, colors: [:red, :blue] },
  tennis_ball: { weight: 58, colors: [:yellow, :white] },
  golf_ball: { weight: 45, colors: [:white] }
}
```

Для каждого ключа выше мы определяем свой хеш, который, в свою очередь, представляет такие параметры, как `weight` (вес, число, тип *Integer*) и доступные для этого товара цвета (`colors`, массив символов). Несмотря на то что последнюю строку можно было записать как

{line-numbers: false}
```
  golf_ball: { weight: 45, color: :white }
```

(т.к. мяч для гольфа доступен в одном цвете — в белом), мы намеренно записываем этот хеш универсальным образом, где `:white` — это один элемент в массиве, который доступен по ключу `:colors`. В этом случае говорят «сохранить схему [данных]». Схема данных — это просто определенная структура, которой мы решили придерживаться. Мы делаем это по трем причинам:

* чтобы не было путаницы. Каждая строка будет похожа на предыдущую;
* чтобы оставался массив `colors`, в который в будущем можно будет добавить мяч для гольфа другого цвета;
* чтобы код, который работает с этой структурой данных, оставался одним и тем же. Если добавить для какой-то строки отдельное свойство (`color`), то придется делать проверку с помощью конструкции `if` и иметь две ветки кода.

Другими словами, обычно JSON-объекты придерживаются какой-то определенной структуры. Но как же получить доступ к такому сложному объекту? Таким же образом, каким мы получаем доступ к массиву, с помощью нескольких операций доступа. Выведем все цвета мяча для тенниса:

{line-numbers: false}
```ruby
arr = obj[:tennis_ball][:colors]
puts arr
```

Выведем вес мяча для гольфа:

{line-numbers: false}
```ruby
weight = obj[:golf_ball][:weight]
puts weight
```

Добавим новый цвет `:green` в массив цветов мяча для тенниса:

{line-numbers: false}
```ruby
obj[:tennis_ball][:colors].push(:green)
```

Структура, которую мы определили выше, начинается с открывающейся фигурной скобки. Это означает, что JSON имеет тип *Hash*. Но структура JSON может также быть массивом. Все зависит от нужд нашего приложения. Если наша задача — вывод списка, а не обращение к хешу как к источнику данных, то JSON может быть записан другим образом:

{line-numbers: false}
```ruby
obj = [
  { type: :soccer_ball, weight: 410, colors: [:red, :blue] },
  { type: :tennis_ball, weight: 58, colors: [:yellow, :white] },
  { type: :golf_ball, weight: 45, colors: [:white] }
]
```

По сути, эта структура — не что иное, как массив объектов с какими-то свойствами:

{line-numbers: false}
```ruby
obj = [ {}, {}, {} ]
```

Другими словами, в зависимости от нашей задачи мы можем использовать ту или иную структуру данных, состоящую из массивов и хешей.

X> ## Задание 1
X> Корзина пользователя в интернет-магазине определена следующим массивом (`qty` — количество единиц товара, которое пользователь хочет купить, `type` — тип):

{line-numbers: false}
```ruby
cart = [
  { type: :soccer_ball, qty: 2 },
  { type: :tennis_ball, qty: 3 }
]
```

А наличие на складе — следующим хешем:

{line-numbers: false}
```
inventory = {
  soccer_ball: { available: 2, price_per_item: 100 },
  tennis_ball: { available: 1, price_per_item: 30 },
  golf_ball: { available: 5, price_per_item: 5 }
}
```

Написать программу, которая выводит на экран цену всех товаров в корзине (`total`), а также сообщает, возможно ли удовлетворить запрос пользователя — набрать все единицы товара, которые есть на складе.
