## Интерполяция строк

Читаемость программы можно значительно улучшить, добавив интерполяцию строк:

{caption: "Пример интерполяции строк"}
```ruby
puts "Your age?"
age = gets.to_i
age_months = age * 12
puts "Your age is #{age_months}"
```

В последней строке нам не пришлось заниматься приведением типов. Каждый объект в руби может быть преобразован в строку (см.метод *to_s* у класса *Object*). Поэтому существует универсальный синтаксис для любого типа — интерполяция.

Хитрость интерполяции в том, что вычисляется выражение внутри фигурных скобок и результат вычисления приводится к строке. Мы попробовали одно выражение `age_months`, результат этого выражения — значение переменной. Но мы можем изменить нашу программу и попробовать интерполяцию поинтереснее:

```ruby
puts "Your age?"
age = gets.to_i
puts "Your age is #{age * 12}"
```

Нет необходимости в создании еще одной переменной, мы можем посчитать выражение прямо внутри фигурных скобок. Результат работы программы будет одинаковым.

На первый взгляд может показаться, что интерполяция — незначительное улучшение. Даже в старых версиях языка JavaScript можно было пользоваться простым знаком плюс:

{caption: "Конкатенация строк в старом JavaScript", line-numbers: false}
```js
$ node
> "Your age is " + 30 * 12
'Your age is 360'
```

Но в новой версии JavaScript (ES 6 и выше) тоже появилась интерполяция строк, несмотря на то, что она в общем-то и не нужна. Просто эта функциональность значительно облегчает работу программиста:

{caption: "Интерполяция строк в новом JavaScript (ES6)", line-numbers: false}
```js
$ node
> `Your age is ${30 * 12}`
'Your age is 360'
>
```

Обратите внимание, что в JavaScript для интерполяции используются обратные кавычки (backticks), а в руби — двойные.

Интерполяция строк полезна, когда нам приходится иметь дело с несколькими переменными. Рассмотрим программу:

```ruby
puts "Your name?"
name = gets

puts "Your age?"
age = gets.to_i

puts "Your city?"
city = gets

puts "=" * 80
puts "You are #{name}, your age in months is #{age * 12}, and you are from #{city}"
```

Результат работы программы:

{line-numbers: false}
```
Your name?
Roman
Your age?
30
Your city?
San Francisco
======================================================================
You are Roman
, your age in months is 360, and you are from San Francisco
```

Почти получилось. Мы использовали интерполяцию строк и после визуального разделителя вывели все с помощью одной строки. Однако, что-то пошло не так. Мы видим, что после слова “Roman” идет перенос строки. В чем же дело? Дело в том, что функция *gets* возвращает строку с символом “\n”. На самом деле это один символ с порядковым номером 10 в стандартной таблице всех символов. Была договоренность, что если этот символ выводится на консоль, то последующий вывод будет начинаться с новой строки. 

Давайте докажем, что *gets* возвращает не просто строку. Выполним в REPL:

{line-numbers: false}
```ruby
$ irb
> x = gets
Hi
 => "Hi\n"
> x.class
 => String
> x.size
 => 3
```

Мы попробовали присвоить переменной `x` значение *gets*. Т.к. REPL печатает результат выражения, то мы видим "Hi\n". Т.е. REPL уже нам говорит о том, что в конце стоит управляющий символ. Далее мы проверили тип с помощью `.class` — строка. И потом обратились к методу `.size`, который возвращает длину строки. Несмотря на то, что мы ввели строку из двух символов, размер строки равен трем. Потому что оператор *gets* «записал» в строку еще управляющий символ перевода строки.

Когда мы делали интерполяцию выше, этот перевод никуда не делся и добавился в результат вычисления строки. Поэтому в нас произошел переход на следующую строку и вывод получился неаккуратным. Исправим это недоразумение:

```ruby
puts "Your name?"
name = gets.chomp

puts "Your age?"
age = gets.to_i

puts "Your city?"
city = gets.chomp

puts "=" * 80
puts "You are #{name}, your age in months is #{age * 12}, and you are from #{city}"
```

Проверим работу программы:

{line-numbers: false}
```
$ ruby app.rb
Your name?
Roman
Your age?
30
Your city?
San Francisco
======================================================================
You are Roman, your age in months is 360, and you are from San Francisco
```

Заработало! Метод `chomp` класса *String* отрезает ненужный нам перевод строки. Важно отметить, что интерполяция строк работает только с двойными кавычками. Одинарные кавычки могут использоваться наравне с двойными за тем исключением, что интерполяция строк в них намеренно не поддерживается. Более того, инструменты статического анализа кода (например, [*Rubocop*](https://rubocop.org/)) выводят предупреждение, если вы используете двойные кавычки и не используете интерполяцию. В дальнейшем мы будем использовать одинарные кавычки, если интерполяция строк не нужна.

X> ## Задание 1
X> Посмотрите документацию к методу `chomp` и `size` класса *String*.
```
X> ## Задание 2
X> Напишите программу для подсчета годовой зарплаты. Пользователь вводит размер заработной платы в месяц, а программа выводит размер заработной платы в год. Допустим, что пользователь каждый месяц хочет откладывать 15% своей зарплаты. Измените программу, чтобы она выводила не только размер заработной платы, но и размер отложенных за год средств. Измените программу, чтобы она выводила размер отложенных средств за 5 лет.


