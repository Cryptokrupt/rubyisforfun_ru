## Массивы массивов (двумерные массивы)

При объявлении массива мы можем указать любой тип. Например, *String*:

{line-numbers: false}
```ruby
$ irb
> Array.new(10, 'hello')
=> ["hello", "hello", "hello", "hello", "hello", "hello", "hello", "hello", "hello", "hello"]
```

Или *Boolean* (несуществующий тип, созданный нами намеренно. Этот тип представлен двумя типами *TrueClass* и *FalseClass*):

{line-numbers: false}
```ruby
$ irb
> Array.new(10, true)
=> [true, true, true, true, true, true, true, true, true, true]
```

Или *Integer*:

{line-numbers: false}
```ruby
$ irb
> Array.new(10, 123)
=> [123, 123, 123, 123, 123, 123, 123, 123, 123, 123]
```

Другими словами, элемент массива это любой объект. Если элемент массива любой объект и сам по себе массив это объект, значит мы можем объявить массив массивов:

{line-numbers: false}
```ruby
$ irb
> Array.new(10, [])
 => [[], [], [], [], [], [], [], [], [], []]
```

Если мы обратимся по какому-либо индексу, то мы получим массив внутри массива. Например, индекс 4 выбирает пятый по счету элемент. Давайте попробуем обратиться к элементу по индексу 4:

{line-numbers: false}
```ruby
$ irb
> arr = Array.new(10, [])
 => [[], [], [], [], [], [], [], [], [], []]
> element = arr[4]
 => []
> element.class
 => Array
```

Мы видим, что этот элемент — массив, тип Array. Массив этот пустой. Когда мы ввели `element = arr[4]`, REPL посчитал нам это выражение и ответил `[]` (к слову, если бы это была последняя строка метода, то метод вернул бы `[]`). Что мы можем сделать с пустым массивом? Добавить туда что-нибудь. Давайте это сделаем:

{line-numbers: false}
```ruby
element.push('something')
```

Вот такой результат мы ожидаем в переменной `arr` — массив массивов, где четвертый по индексу (и пятый по порядковому номеру) элемент что-то содержит наше значение:

{line-numbers: false}
```ruby
[[], [], [], [], ['something'], [], [], [], [], []]
```

Проверим в REPL:

{line-numbers: false}
```ruby
> arr
=> [["something"], ["something"], ["something"], ["something"], ["something"], ["something"], ["something"], ["something"], ["something"], ["something"]]
```

Ой-ой-ой! Что-то пошло не так! Посмотрим на текст программы целиком, что же в ней неправильно:

{line-numbers: false}
```ruby
arr = Array.new(10, [])
element = arr[4]
element.push('something')
puts arr.inspect # способ вывести информацию так же, как ее выводит REPL
```

Где ошибка? Слово знатокам, время пошло! Это, кстати, может быть хитрым вопросом на интервью. Вопрос не самый простой и подразумевает знакомство и понимание принципов работы языка руби, что такое объект, что такое ссылка. Помните, мы с вами немного говорили про ссылки? Когда есть подъезд и каждый звонок ведет в собственную квартиру? Мы можем повторить такой же фокус с классом *String*:

{line-numbers: false}
```ruby
arr = Array.new(10, 'something')
element = arr[4]
element.upcase!
puts arr.inspect # способ вывести информацию на экран также, как ее выводит REPL
```

Ожидаемый результат:

{line-numbers: false}
```
["something", "something", "something", "something", "SOMETHING", "something", "something", "something", "something", "something"]
```

Реальный результат:

{line-numbers: false}
```
["SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING"]
```

Что же тут происходит? А дело в том, что при инициализации массива мы передаем ссылку (`reference`) на один объект. Т.к. мы передаем параметр один раз, то и объект в массиве всегда «размножается по ссылке». Т.е. на самом деле при такой инициализации массива, ячейки содержат не сам объект, а ссылку на объект. Чтобы этого не происходило, нужно чтобы ссылки на объекты были разные. При этом, конечно, и сами объекты будут разные — они будут располагаться в разных областях памяти, и если мы что-то изменим, то это не изменит состояние (`state`) других объектов.

Если проводить аналогию с подъездом и жильцами дальше, то можно представить следующее. Мы принесли большую распределительную коробку (массив) и хотим поместить туда 10 звонков. Звонки поместили, но все провода идут к одной квартире. Поэтому, когда мы звоним в любой звонок, нам отвечают одни и те же жильцы. Нам просто нужны ссылки на разные квартиры и тогда все будет работать. Поэтому конструкция с массивом массивов неправильная, никогда так не делайте:

{line-numbers: false}
```ruby
arr = Array.new(10, []) # <-- НЕПРАВИЛЬНО!
``` 

Просто потому, что массив внутри массива предназначен для того, чтобы меняться. Зачем нам пустой массив? Ведь мы захотим когда-нибудь туда что-то записать. В случае со строками все немного проще, такая конструкция допустима:

{line-numbers: false}
```ruby
arr = Array.new(10, 'something')
``` 

Но при одной оговорке — что мы не будем использовать опасные (`danger`) методы. Т.е. методы класса *String* с восклицательным знаком на конце, которые меняют состояние объекта. Теперь вы понимаете почему они опасные? В случае с числами все еще проще:

{line-numbers: false}
```ruby
arr = Array.new(10, 123)
``` 

В классе *Integer* нет опасных методов, поэтому, даже если у вас есть доступ к объекту, вы не сможете его изменить (но сможете заменить). Если вы напишите `arr[4] = 124`, то вы замените ссылку в массиве на новый объект, который будет представлять число `124`. Ссылки на один и тот же объект `123` в других частях массива сохранятся. Т.е. мы и получим то, что ожидаем:

{line-numbers: false}
```ruby
$ irb
> arr = Array.new(10, 123)
 => [123, 123, 123, 123, 123, 123, 123, 123, 123, 123]
> arr[4] = 124
 => 124
> arr
 => [123, 123, 123, 123, 124, 123, 123, 123, 123, 123]
```

Ничего страшного, если эти детали вам покажутся сложными. На практике редко приходится работать с очень сложными вещами, обычно требуется понимание этих принципов, способность разобраться или найти решение в Интернет. Некоторым опытным программистам это высказывание может не понравиться, но авторы книги рекомендуют не обращать внимание на чье-либо мнение, скорее находить удаленную работу и учиться уже на практике. Опыт учеников «руби школы» показывает, что этот путь верный.

Но как же нам все-таки объявить двумерный массив? Представим, что нам нужно сделать игру «Морской бой», где каждую строку на поле битвы представляет отдельный массив (ну а столбец — это индекс в этом отдельном массиве). Если бы у нас была одна строка на 10 клеток, то можно было бы обойтись одним массивом, но нам нужно 10 строк по 10 клеток. Как объявить такой массив, чтобы каждый элемент массива представлял собой ссылку на другой, совершенно отдельный элемент?

Для объявления двумерного массива в языке C# используется довольно простая конструкция:

{line-numbers: false}
```csharp
var arr = new int[10, 10];
```

Для типа *String*:

{line-numbers: false}
```csharp
var arr = new string[10, 10];
arr[9, 9] = "something";
```

Но в Ruby и JavaScript это, на удивление, делается немного сложнее. Правильный синтаксис для объявления двумерного массива 10 на 10 в руби (массив будет заполнен `nil` — объектом, представляющим пустое значение):

{caption: "Правильный способ определения двумерного массива в Ruby", line-numbers: false}
```ruby
arr = Array.new(10) { Array.new(10) }
```

Вау! Но почему так? Давайте разберемся. Метод `new` (на самом деле это метод `initialize`, но это пока не важно) принимает один параметр и один блок. Первый параметр — фиксированный, это количество элементов массива. А второй параметр — блок, который надо исполнить для каждого элемента. Результат выполнения этого блока и будет новым элементом. Блок будет запускаться 10 раз (в нашем случае). Ничто не мешает написать нам блок таким образом:

{line-numbers: false}
```ruby
arr = Array.new(10) { 'something' }
```

Результат будет аналогичен уже известному нам коду:

{line-numbers: false}
```ruby
arr = Array.new(10, 'something')
```

В REPL и тот, и другой вариант выглядят одинаково:

{line-numbers: false}
```ruby
$ irb
> arr1 = Array.new(10) { 'something' }
 => ["something", "something", "something", "something", "something", "something", "something", "something", "something", "something"]

> arr2 = Array.new(10, 'something')
 => ["something", "something", "something", "something", "something", "something", "something", "something", "something", "something"]
```

Но есть одна существенная разница. Первая конструкция при инициализации вызывает блок. В результате вызова блока каждый раз создается новое значение `something` в новой области памяти. А во втором случае (когда мы создаем `arr2`) берется `something`, который мы передали через параметр. Он создается в области памяти перед тем, как параметр будет передан в метод `new`, и используется для всех ячеек массива, всегда один и тот же.

Это очень просто доказать. Для людей, недостаточно знакомых с языком руби, это кажется волшебным трюком. Модифицируем элемент по индексу 0 в первом массиве, где каждый элемент это всегда ссылка на отдельную строку, для каждого элемента массива ссылка разная.

{line-numbers: false}
```ruby
arr1[0].upcase!
```

Выведем результат вычисления `arr1` на экран:

{line-numbers: false}
```ruby
> arr1
 => ["SOMETHING", "something", "something", "something", "something", "something", "something", "something", "something", "something"]
```

Изменилось только первое значение, что доказывает, что ссылка везде разная. Если же проделать точно такой же трюк со вторым массивом, то поменяется массив целиком, потому что ссылка на элемент во всех ячейках массива одинаковая:

{line-numbers: false}
```ruby
> arr2[0].upcase!
 => "SOMETHING"
> arr2
 => ["SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING"]
```

Если бы мы перед `upcase!` переинициализировали какой-либо элемент, то этот элемент не был бы затронут:

{line-numbers: false}
```ruby
> arr2[4] = 'something'
 => "something"
> arr2[0].upcase!
 => "SOMETHING"
> arr2
 => ["SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "something", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING", "SOMETHING"]
```

Обратите внимание, что в примере выше элемент с индексом 4 не был затронут операцией `upcase!`, т.к. это совершенно другой объект, хотя при выводе на экран нам кажется что все одинаково. Поэтому правильная инициализация массива массивов выглядит так:

{line-numbers: false}
```ruby
arr = Array.new(10) { Array.new(10) }
```

Если нужно заполнить массив значением, отличным от `nil`, передаем его во второй конструктор:

{line-numbers: false}
```ruby
arr = Array.new(10) { Array.new(10, 123) }
```

Заполнить двумерный массив значением `0`:

{line-numbers: false}
```ruby
arr = Array.new(10) { Array.new(10, 0) }
```

Создать массив в 4 строки и 10 столбцов и заполнить его значением `0`:

{line-numbers: false}
```ruby
arr = Array.new(4) { Array.new(10, 0) }
```

Создать массив в 2 строки и 3 столбца и заполнить каждую строку одинаковым объектом `something`:

{line-numbers: false}
```ruby
arr = Array.new(2) { Array.new(3, 'something') }
```

Создать массив в 3 строки и 2 столбца и заполнить каждую строку одинаковым объектом `something`:

```
arr = Array.new(3) { Array.new(2, 'something') }
```

Надеемся, что с созданием двумерных массивов проблем не будет. Когда у нас есть понимание того, что такое массив, что такое двумерный массив, есть смысл остановиться на способе записи двумерного массива с какими либо `pre-defined` (предопределенными) значениями. Одномерный массив записать просто, это массив каких-либо объектов:

{line-numbers: false}
```ruby
arr = [1, 2, 3]
```

Или:

{line-numbers: false}
```ruby
arr = ['one', 'two', 'three']
```

Т.е. массив содержит объекты. Двумерный массив это тот же самый массив, который содержит объекты, с той лишь разницей, что все эти объекты типа *Array*, а не *Integer* или *String*. Чтобы создать массив из трех строк, нам нужно написать:


{line-numbers: false}
```ruby
arr = [..., ..., ...]
```

Но если необходимо создать массив пустых массивов, вместо троеточия нужно просто написать определение пустого массива:

{line-numbers: false}
```ruby
arr = [[], [], []]
```

Давайте определим массив 3 на 3 для игры в крестики нолики, где ноль это нолик, единица — крестик, а пустая клетка это `nil`. Для такой матрицы:

{width: 25%}
![Крестики-нолики](images/046-tic-tac-toe.png)

Массив будет выглядеть следующим образом:

{line-numbers: false}
```ruby
arr = [[0, 0, 1], [nil, 0, nil], [1, nil, 1]]
```

Запись в одну строку можно превратить в более читаемый вид с сохранением функциональности:

{line-numbers: false}
```ruby
arr = [
  [0, 0, 1],
  [nil, 0, nil],
  [1, nil, 1]
]
```

При желании можно добавить сколько угодно пробелов.

X> ## Задание 1 
X> Если вы не попробовали в REPL все написанное выше, то перечитайте и попробуйте.
>
X> ## Задание 2
X> Создайте массив в 5 строк и 4 столбца, заполните каждую строку случайным значением от 1 до 5 (только одно случайное значение для каждой строки). Пример для массива 2 на 3:

{line-numbers: false}
```ruby
[
  [2, 2, 2],
  [5, 5, 5]
]
```

X> ## Задание 3
X> Создайте массив в 4 строки и 5 столбцов, заполните каждую строку случайным значением от 1 до 5 (только одно случайное значение для каждой строки).
>
X> ## Задание 4
X> Создайте массив 5 на 4 и заполните весь массив абсолютно случайными значениями от 0 до 9.
