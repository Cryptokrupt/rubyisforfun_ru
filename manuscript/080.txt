## Subtyping (субтипирование) против наследования

Помимо модулей, существует еще один, более верный способ «наследовать данные и функциональность, способствуя повторному использованию». Речь идет не о том, чтобы бездумно использовать механизм наследования для копирования методов и переменных из любого объекта в любой другой, а о том, чтобы на самом деле выделить подтипы.

Например, утка, кукушка и страус — это подтипы одного типа — птица:

{width: 55%}
![Диаграмма классов](images/080-diagram.png)

В этом случае на основе нашего жизненного опыта мы можем сказать: да, подтипы правильные, а значит, и абстракция целиком верна. И это, кстати, то, что разрешает (`enables`) полиморфизм. Вне зависимости от того, какая именно это птица, мы можем: напоить птицу, накормить птицу, выпустить погулять и т.д. 

С технической точки зрения, в языке Руби `subtyping` осуществляется так же, как и наследование. Например:

{line-numbers: false}
```ruby
class Птица
end

class Утка < Птица
end

class Кукушка < Птица
end

class Страус < Птица
end
```

В языке C# мы бы воспользовались интерфейсами (а не наследованием):

{line-numbers: false}
```csharp
interface Птица {
	void Накормить();
	void Напоить();	
}

interface Утка : Птица {
}

interface Кукушка : Птица {
}

interface Страус : Птица {
}
```

Особенность интерфейсов в том, что в них нет кода — только определение методов. Поэтому нельзя бездумно скопировать код. Но в динамически типизированных языках типа Руби мы или держим интерфейсы в голове, или вводим некий абстрактный класс («Птица» выше) и используем наследование.

Для записи программы с человеком, роботом и собакой можно было бы использовать следующий подход. Ввести некий абстрактный класс, который не имеет смысла сам по себе. И унаследовать от него все три сущности. Например, можно ввести абстрактный класс `Player` (игрок) и создать следующую взаимосвязь между классами:

{width: 50%}
![Демонстрация подтипов/наследования для игры с человеком/роботом/собакой](images/080-diagram-02.png)

Этот подход очень похож на использование модулей. Правда, в этом случае мы точно говорим: мы видим абстракцию, это некий «игрок». Чего бы не случилось в игре, у игрока будут всегда реализованы методы `left`, `right`, `up`, `down`, `label`, всегда будут известны координаты. Любой метод, который будет принимать объект `Dog`, `Human` или `Robot`, может рассчитывать на то, что эти методы присутствуют. Мы также даем понять, что `Dog`, `Human` и `Robot` — это разные сущности. У них есть что-то общее, они являются игроками на поле. Но мы не наследуем человека от робота, как это было раньше. Все общее между этими объектами — методы игрока.

X> ## Задание
X> Не подсматривая в код, который написан чуть ниже, попробуйте написать программу по диаграмме классов на представленном рисунке.

Код программы выглядит следующим образом:

```ruby
class Player
  attr_accessor :x, :y

  def initialize(options={})
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right
    self.x += 1
  end

  def left
    self.x -= 1
  end

  def up
    self.y += 1
  end

  def down
    self.y -= 1
  end

  def label
  end
end

class Robot < Player
  def label
    '*'
  end
end

class Dog < Player
  def up
  end

  def left
  end

  def label
    '@'
  end
end

class Human < Player
  def label
    'H'
  end
end
```

Мы использовали subtyping через наследование для «копирования» функциональности (если сказать точнее, то для выделения общей функциональности). К сожалению или к счастью, в языке Руби нет интерфейсов, поэтому сделать классический `subtyping` и выделить конкретный интерфейс ([extract interface](https://refactoring.guru/ru/extract-interface)) не получится.

Руби является очень гибким языком и дает свободу: все, что вы делаете, остается на вашей совести. Выделить абстракцию можно множеством способов. Более того, язык Руби не запрещает создавать экземпляр абстрактного класса `Player`. Все из-за того, что в Руби нет понятия об абстрактных классах. Также ничто не мешает программисту изменить классы `Dog`, `Human` или `Robot`, добавив в каждый из этих классов разные методы, которые бы «испортили» универсальный интерфейс.

Возможно, это не такая серьезная проблема, когда программа небольшая. Но представьте, что вы пришли на новую работу и перед вами большой проект. Программист Геннадий создал класс `Player`, вы посмотрели через `git` (система контроля версий и изменений файлов) —  файл «player.rb» был добавлен 5 лет назад. Программист Геннадий больше не работает в компании. Как узнать о его намерении? Можно ли сейчас, через 5 лет, создавать экземпляр класса `Player`? А если очень хочется?

В любом случае, использовать или не использовать наследование в языке Руби — решать вам. Если вы не уверены в выбранной абстракции, используйте модули и честно копируйте код. Если вам кажется, что абстракция правильная, то создавайте абстрактный класс, который будет содержать общие для всех подклассов методы и данные.
