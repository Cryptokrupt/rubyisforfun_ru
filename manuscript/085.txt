## Отладка с использованием консольного отладчика

Мы уже знакомы с альтернативным `REPL`, который называется `Pry`. В `pry` реализовано больше возможностей, чем в `irb`. Также `pry` может использоваться не только как `REPL`, но и как отладчик. В этой главе мы рассмотрим минимальные возможности `pry` в качестве отладчика. Умение пользоваться этим инструментом может сэкономить вам массу времени.

Если по каким-то причинам `pry` еще не установлен в вашей системе (а это можно проверить с помощью консольной команды `which pry`), то это легко исправить с помощью команды:

{line-numbers: false}
```shell
$ gem install pry pry-doc
```  

С помощью этой команды мы устанавливаем два `gem’a`. Сам `pry` и `pry-doc`, который является плагином для `pry` и предоставляет расширенную документацию по «нативным» (`native`) методам языка руби. 

Запускать pry мы уже умеем. А команда `help` выводит справку по возможным командам:

{line-numbers: false}
```shell
$ pry
> help
Help
  help               Show a list of commands or information about a specific command.

Context
  cd                 Move into a new context (object or scope).
  find-method        Recursively search for a method within a class/module or the current namespace.
  ls                 Show the list of vars and methods in the current scope.
  pry-backtrace      Show the backtrace for the pry session.
  raise-up           Raise an exception out of the current pry instance.
  reset              Reset the repl to a clean state.
  watch              Watch the value of an expression and print a notification whenever it changes.
  whereami           Show code surrounding the current context.
  wtf?               Show the backtrace of the most recent exception.
...
```

По каждой команде из этого списка можно получить подробную справку, если ввести название команды и через пробел в конце добавить `-h`:

{line-numbers: false}
```
[1] pry(main)> whereami -h
Usage: whereami [-qn] [LINES]

Describe the current location. If you use `binding.pry` inside a method then
whereami will print out the source for that method.
...
```

Возможности `pry` раскрываются более полно не в качестве `REPL`, а в качестве отладчика. Посмотрим на программу, которая возводит в квадрат какое-то случайное число:

{line-numbers: false}
```ruby
def random_pow
  pow(rand(1..10))
end

def pow(x)
  x ^ 2
end

puts random_pow
```

После того как мы запустили эту программу, на экран было выведено число 6. Очень странно, ведь функция `rand` на второй строке генерирует целое случайное число от 1 до 10, а следовательно возможный результат это одно из следующих значений: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 (в программе намеренно допущена ошибка, сможете ли вы ее увидеть?).

Как найти ошибку в этой программе? Один из способов — воспользоваться `puts` и привести программу к следующему виду:

```ruby
def random_pow
  pow(rand(1..10))
end

def pow(x)
  puts "Pow parameter: #{x}"
  x ^ 2
end

puts random_pow
```

После запуска программы мы можем увидеть передаваемый в функцию параметр и результат вычисления:

{line-numbers: false}
```
Pow parameter: 3
1
```

Хм. Входной параметр 3, а тройка в квадрате это 9, но никак не 1. Что же тут происходит? В случае с такой простой программой опытный программист найдет ответ довольно быстро. Но когда программа большая, а функция скрыта и «добраться» до ее вызова сложно (например, нужно пройти через несколько этапов — регистрация, подтверждение емайла, и т.д.), изменять каждый раз программу и проходить эту последовательность действий может быть очень накладно — потребуется много времени. Поэтому нам нужен другой способ.

Программисты говорят — нужно установить `breakpoint` (точку остановки) в определенном месте программы. И когда программа дойдет до этой точки, она будет остановлена и управление будет передано человеку. Человек с помощью специальных инструментов сможет проанализировать программу именно в этой точке: посмотреть на переменные, переданные параметры, на стек вызова, другими словами — иметь на руках какой-то текущий контекст, а не просто код на экране и теоретическое представление о том, как он работает.

Давайте установим breakpoint с помощью `pry`:

```ruby
require 'pry'

def random_pow
  pow(rand(1..10))
end

def pow(x)
  binding.pry
  x ^ 2
end

puts random_pow
```

Первая строка говорит о том, что мы требуем (`require`) загрузки библиотеки `pry`. По-умолчанию, для быстроты выполнения программы, абсолютно все установленные gem’ы не загружаются. Поэтому нужно воспользоваться специальным синтаксисом и написать `require`. Разумеется, что `gem` при этом должен быть установлен в вашей системе. С точки зрения руби `gem` это просто сторонний код, который написал какой-то неизвестный разработчик. Поэтому при установке gem’ов (команда `gem install …`) они скачиваются из Интернета, а при `require` они загружаются в память с вашего диска.

Примечание: в будущем вы будете использовать фреймворк Rails, в котором достаточно поместить `gem` в специальный список (файл `Gemfile`), и если все сделать правильно, то все gem’ы из этого списка будут загружены в память автоматически.

`binding.pry` мы поместили на ту же строку, где раньше был `puts` с выводом отладочной информации. `binding.pry` это специальный синтаксис, который нужно запомнить. Он говорит о том, что в этом месте должна произойти остановка программы и должен быть вызван отладчик.

Обратите внимание, что раньше мы запускали `pry` непосредственно из командной строки. А в этот раз мы запустили программу обычным способом:

{line-numbers: false}
```shell
$ ruby app.rb
```

Программа запустилась, было определено два метода, был запущен метод `random_pow`, который в свою очередь вызвал pow, и в котором мы в итоге оказались:

{line-numbers: false}
```
$ ruby app.rb

From: /Users/ro/work/book/app.rb @ line 8 Object#pow:

     7: def pow(x)
 =>  8:   binding.pry
     9:   x ^ 2
    10: end

[1] pry(main)>
```

Стрелка слева показывает где мы находимся. Если ввести команду `whereami` (надо запомнить) — то вы увидите место текущего брейкпоинта.

Сейчас вместо «пустого» состояния `pry`, которое мы раньше получали при запуске `pry` из терминала, мы находимся в состоянии запущенной программы, но с тем же самым инструментом `pry`. Что это нам дает в плане отладки:

* Мы можем посмотреть значения переменных (например, переменной `x`)
* Мы можем изменить значения переменных
* Мы можем вызвать какой-либо метод один или несколько раз
* Мы можем вставить (например, скопированный из буфера обмена код) и посмотреть как он работает
* Мы можем попытаться вычислить результат выполнения следующей строки (например, путем ее копирования или просто ввода с клавиатуры) и посмотреть что произойдет

Другие возможности `pry`, когда мы находимся в точке остановки:

* Команда `next` выполнит следующую строку. После этого снова можно посмотреть значение переменных, чтобы понять что не так с программой.
* Команда `exit” вернет выполнение в программу. Т.е. это выход из `Pry`, но не из программы. Можно было дать более правильное имя этой команде `continue` (продолжить).
* Команда `exit!` (с восклицательным знаком) прервет выполнение программы с выходом в терминал.
* Команда `whereami` (от англ. Where Am I — где я?) может быть полезна когда, например, после вывода большого текста на экран (или очистки экрана кодом из нашей программы) мы все еще хотим знать в каком месте программы мы в данный момент находимся.

Научиться пользоваться сразу всеми остальными командами за один раз вряд ли получится, поэтому выше перечислены только основные команды без которых не обойтись. Рекомендуем почаще пользоваться командой `help` и пробовать новые возможности.

Но что делать в нашем случае и как найти ошибку? Давайте попробуем вывести текущее значение `x`, а потом ввести с клавиатуры следующую строку (`x ^ 2`) и посмотреть на результат выполнения этой операции:

{line-numbers: false}
```
[2] pry(main)> whereami

From: /Users/ro/work/book/app.rb @ line 8 Object#pow:

     7: def pow(x)
 =>  8:   binding.pry
     9:   x ^ 2
    10: end

[3] pry(main)> x
2
[4] pry(main)> x ^ 2
0
```

Любопытно! С помощью отладчика мы узнали, что значение `x` равно двум, а результат вычисления выражения `x ^ 2` равен нулю. Что является не тем результатом, который мы ожидаем. Мы ожидаем, что два в квадрате будет равно четырем, но не нулю!. Другими словами, с помощью `pry` удалось найти ту строку, в которой присутствует ошибка.

Запись `x ^ 2` является неправильной в языке руби (но правильной в некоторых других языках). Для возведения в степень необходимо использовать `**`. Правильная программа должна выглядеть следующим образом:

{line-numbers: false}
```ruby
def random_pow
  pow(rand(1..10))
end

def pow(x)
  x ** 2 # ПРАВИЛЬНОЕ ВОЗВЕДЕНИЕ В КВАДРАТ
end

puts random_pow
```

Мы познакомились с основными возможностями `pry`. Отныне если в вашей программе возникнет ошибка, вы будете знать как ее найти: установить `breakpoint` и попытаться понять что происходит во время работы программы.

Отдельно хотелось бы отметить малознакомую, но полезную команду `system('reset')`. Эта команда не является стандартной в `pry`: `system` это просто метод языка руби, который выполняет команду оболочки `reset` (не путайте с командой `reboot`, которая перезагружает компьютер). Если ввести `system('ls')`, то можно получить список файлов в текущей директории, а `system('pwd')` покажет путь к текущей директории процесса.

Справка по `reset` (запустите `man reset` в вашем терминале) говорит о том, что команда используется для сброса настроек оболочки в настройки по-умолчанию.

Что же это могут быть за настройки и зачем вызывать `reset` из `pry`? Если вы разрабатываете небольшую программу, то эта команда вам не нужна. Но на практике программист обычно работает с (относительно) большим Rails-проектом. В больших проектах существует множество gem’ов, которые в зависимости от разных обстоятельств, могут выводить в консоль отладочную информацию в самый неподходящий момент. Такая же отладочная информация может поступать и от самого приложения (например, вывод отладочной информации в консоль по таймауту). Иногда эта информация сбивает каким-то образом настройки терминала и возникает необходимость вернуть эти настройки обратно без перезапуска отладчика. Сделать это можно с помощью `system('reset')` или просто взяв слово `reset` в обратные кавычки (`backticks`):

{line-numbers: false}
```
[1] pry(main)> `reset`

(произошла очистка экрана)

""
[2] pry(main)> whereami
...
```