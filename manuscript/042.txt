## Немного про each

Массив представлен типом [Array](https://ruby-doc.org/core-2.5.1/Array.html) и в этом типе реализован метод `each` (каждый). Вы уже познакомились с этим методом, когда для каждого элемента массива мы выполняли какое-то действие. Технически метод `each` принимает блок. Как уже было сказано ранее, мы можем передать блок в любой метод, дальнейшее поведение программы зависит от того, что «под капотом» у этого метода.

Так вот, метод `each` запускает то, что внутри блока для каждого элемента массива. Другими словами, маленькую подпрограмму для каждого элемента (`element`, `item`):

{line-numbers: false}
```ruby
arr.each do |item|
  # внутри блока идет подпрограмма
  # может занимать несколько строк
end
```

Или в одну строку:

{line-numbers: false}
```ruby
arr.each { |item| ...или одну строку... }
```

В блок последовательно передается параметр — очередной элемент массива. Т.е. то, что вы написали внутри `each` между `do` и `end` это и есть блок. Таким образом в руби реализован обход массива (иногда говорят «итерация массива», «итерация через массив», `array iteration`, `iteration over array`, реже — `array traversal`).

Имя параметра мы можем задать любое. В примере из предыдущей главы мы задавали имя `word`, когда считали количество букв в слове. В записной книжке у нас был `element`. Мы можем указать любое имя, желательно только чтобы оно было понятно программисту. Работа `each` (и любого другого метода, который работает с блоками) похожа на запуск вашего собственного метода:

{line-numbers: false}
```ruby
def my_method(word)
  puts "В слове #{word} #{word.size} букв"
end
```

Только с блоком это выглядит немного иначе:

{line-numbers: false}
```ruby
arr.each do |word|
  puts "В слове #{word} #{word.size} букв"
end
```

Жаль, что в руби нельзя передать название метода для запуска:

{line-numbers: false}
```ruby
arr.each my_method
```

Было бы более понятно. Примечание: на самом деле можно записать эту конструкцию похожим образом, но 1) не совсем так 2) с ограничениями 3) никто так все равно не делает.

Метод `each` реализован также в некоторых других типах. Обход чего-либо в общем и целом является довольно популярной операцией в программировании, поэтому `each` можно увидеть даже там, где его, казалось бы, быть не может. Вариация `each` для типа *String*:

{line-numbers: false}
```
$ irb
> 'hello'.each_char { |x| puts x }
h
e
l
l
o
```

Метод `each` для типа *Range*:

{line-numbers: false}
```ruby
(1001..1005).each do |x|
  puts "Я робот #{x}"
end
```

Результат:

{line-numbers: false}
```
Я робот 1001
Я робот 1002
Я робот 1003
Я робот 1004
Я робот 1005
```