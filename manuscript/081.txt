## Статические методы

Существуют методы экземпляра класса (`instance methods`), а существуют методы класса (`class methods`). В других языках программирования методы класса называются «статические методы». То же самое можно сказать и про переменные, существуют `instance variables`, а существуют `class variables`, которые используются реже (также существуют т.н. `local variables` — переменные, доступные только внутри определенного метода). Разницу между двумя разными типами методов (и переменных) необходимо усвоить, т.к. она часто встречается в литературе. Но в чем же заключается эта разница?

Представьте себе чертёж какой-либо детали. На чертеже присутствует рисунок, в котором указаны размеры, по этому образцу будет изготавливаться деталь. Это все переменные и методы экземпляра, они не имеют смысла без создания экземпляра этой детали. Но внизу чертежа есть также место, в котором указан автор чертежа. Представьте, что было изготовлено 1000 деталей и вдруг меняется автор. Каким-то образом оказалось, что на самом деле над чертежом работал не Иванов, а Сидоров. Поэтому берут ластик, стирают фамилию «Иванов» на самом чертеже и пишут новую.

Для тысячи изготовленных деталей это не очень важно, они будут прекрасно работать и без этой метаинформации. Но если кто-то спросит «А кто сделал такой хороший болт?», то ответ уже будет другим. Так вот, метаинформация — это и есть переменные и методы класса (`class methods`, `class variables`, часто говорят «статические методы», «статические переменные»). А размеры и другие технические детали — это обычные переменные и методы экземпляра (`instance methods`, `instance variables`).

Многие программисты не любят статические методы и переменные, и этому есть объяснение. Наверное, не очень приятно, когда при изготовлении деталей в какую-либо рабочую тетрадь была записана фамилия инженера «Иванов», а потом эта фамилия на чертеже поменялась. Придется просматривать все рабочие тетради и делать там исправления. Но это еще полбеды. Представьте, что на чертеже указан материал изготовления и материал был «сталь», а стал «пластик». Уже готовые детали, которые захотят узнать о том, из чего они сделаны, будут получать неправильный ответ.

Поэтому статические методы и статические переменные нужно использовать с осторожностью, особенно когда в одном классе существуют как статические, так и нестатические переменные или методы. Для лучшего понимания рассмотрим класс со статическим методом:

{line-numbers: false}
```ruby
class Person
  def self.say_something
	puts 'Hi there!'
  end
end

Person.say_something
```

В последней строке мы вызываем этот класс особым образом, указывая имя класса и после этого название метода. Обратите внимание, что мы не создаем экземпляра класса. Сравните этот код с аналогичным, но без использования статического метода:

{line-numbers: false}
```ruby
class Person
  def say_something
	puts 'Hi there!'
  end
end

dude = Person.new
dude.say_something
```

Мы объявили переменную `dude`, которая представляет собой экземпляр какого-то человека. И после этого мы просим этот экземпляр что-нибудь сказать.

Кажется, что две программы выше выполняют одну и ту же функцию, но все меняется, когда появляется состояние. Представим, что нам нужно, чтобы человек сказал свое имя. Что мы сделаем, когда мы объявляем программу обычным образом? Передадим в конструктор имя, которое и будет частью состояния:

{line-numbers: false}
```ruby
class Person
  def initialize(name)
	@name = name
  end

  def say_your_name
	puts "My name is #{@name}"
  end
end

dude = Person.new('Sam')
dude.say_your_name
```

Код программы выше до последней строки — подготовительная работа для создания живого организма. Когда он создан, вызывается `dude.say_your_name`. Объект `dude` живой, у него есть состояние. Можно было бы задать и другие параметры — давление крови, список друзей и т.д. Но когда мы говорим про статический класс, все выглядит иначе. Чтобы вывести имя, нам нужно передать его в качестве аргумента:

{line-numbers: false}
```ruby
class Person
  def self.say_your_name(name)
	puts "My name is #{name}"
  end
end

Person.say_your_name('Sam')
```

Несмотря на то что программа выглядит проще, в ней нет живого объекта. Есть только имя, которое существует независимо ни от чего. Мы вроде бы обращаемся к человеку (ведь класс называется `Person`), но этот класс не представляет живого человека. Можно написать:

{line-numbers: false}
```ruby
Person.say_your_name('Sam')
Person.say_your_name('Pat')
Person.say_your_name('Val')
```

И все это будет исполнено. Это не выглядит естественно. Программа выглядела бы более правильно, если бы класс и методы назывались иначе:

{line-numbers: false}
```ruby
class Megaphone
  def self.shout(whatever)
	puts whatever.upcase
  end
end

Megaphone.shout('Hello')
```

(В английском языке «shout» означает «кричать», «громко говорить», метод выше преобразует строку в верхний регистр и выводит ее на экран.)

То есть существует какой-то мегафон, возможно в единственном виде, нигде таких больше нет. И в этот мегафон можно что-то сказать, и он будет говорить громко. В этом случае использование статического метода выглядит оправданно, с некоторыми оговорками. Даже в этом случае мы можем сказать «а ведь мегафон может быть разного цвета, иметь разные характеристики». Возможно, это не важно сейчас, но вы никогда не знаете, что будет в будущем, вдруг потребуется раскрасить мегафон в разные цвета?

Добро пожаловать в волшебный мир разработки программного обеспечения! Как вы уже поняли, выбрать правильную абстракцию не так просто, и выбор правильной абстракции стал камнем преткновения не в одном коллективе. Много было истоптано клавиатур в порывах виртуальных битв за тот или иной подход. Но [вот что говорит об этом Сэнди Мэтз](https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction):

> duplication is far cheaper than the wrong abstraction
> ...
> prefer duplication over the wrong abstraction

Другими словами, если вы не знаете, какая абстракция верна, а какая нет, просто дублируйте код, это обходится в итоге дешевле, чем «городить огород».

Мы пришли к выводу, что иногда статические методы использовать оправданно, а иногда в них не много смысла. Многие профессиональные программисты советуют избегать статических методов, но правда состоит в том, что статические методы присутствуют в сторонних библиотеках, фреймворках, а также в самом языке Руби. Поэтому вам придется с ними сталкиваться.

Правило хорошего тона заключается в том, чтобы использовать статические методы там, где состояния нет и точно не будет. Но в этом случае инструмент статического анализа кода `Rubocop` может выдать предупреждение о том, что [«если не планируется создавать экземпляры класса, то лучше использовать модули»](https://github.com/rubocop-hq/ruby-style-guide#modules-vs-classes).

Поэтому более правильным будет использовать модуль, а не статический класс:

{line-numbers: false}
```ruby
module Megaphone
  module_function

  def shout(whatever)
	puts whatever.upcase
  end
end

Megaphone.shout('Hello')
```

(Значение `module_function` объясняется по той же ссылке чуть ниже.)

Так мы и пришли к выводу, что делать классы только со статическими методами не рекомендуется — нужно использовать модули. А модуль — это — по сути, набор методов, сгруппированных по какому-либо признаку. По какому именно признаку — решает только программист. В языке Руби существуют модули, которые предназначены для работы с файловой системой. Предполагается, что файловая система одна, и мы можем только записать или только прочитать данные, и не может существовать более одной файловой системы в одной операционной системе (что в общем-то неправда, но мы можем с этим согласиться).
