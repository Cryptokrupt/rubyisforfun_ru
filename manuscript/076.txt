## Состояние, пример программы

Вроде бы более или менее что такое состояние понятно. Но как оно используется на практике? В чем его преимущество? Зачем держать состояние внутри объекта и зачем нужна инкапсуляция?

Как уже было замечено выше, объект это живой организм. На практике оказалось полезным не заводить несколько переменных с разными именами, а инкапсулировать их под одной крышей. Представим, что у нас есть робот, который движется по земле, а мы на него смотрим сверху вниз. Робот начинает движение в какой-то точке и может ходить вверх, вниз, влево и вправо произвольное количество шагов.

Кажется, что мы могли бы обойтись и без класса. Завели бы две переменных: `x`, `y`. Если робот ходит вправо, к переменной `x` прибавляется единица. Если вверх, то к переменной `y` прибавляется единица. Не нужны никакие объекты и классы. Все это так, но сложность возникает когда нужно создать двух роботов.

Что получается? Нужно завести 4 переменные, по 2 на каждого робота. Первую пару мы назовем `x1` и `y1`, вторую `x2` и `y2`. Уже неудобно, но можно и обойтись. Но что если роботов будет больше? «Можно обойтись массивом», — скажет читатель и будет прав. Можно создать массив переменных. Это просто будет какая-то структура данных, и какие-то методы будут знать как с ней работать. Но постойте, работать со структурой данных сложнее, чем просто с переменными!

Намного проще написать `x = x + 1`, чем например `x[5] = x[5] + 1`. Другими словами, объекты и классы облегчают создание программы. Давайте создадим описанный класс робота:

{line-numbers: false}
```ruby
class Robot
  attr_accessor :x, :y

  def initialize
    @x = 0
    @y = 0
  end

  def right
    self.x += 1
  end

  def left
    self.x -= 1
  end

  def up
    self.y += 1
  end

  def down
    self.y -= 1
  end
end

robot1 = Robot.new
robot1.up
robot1.up
robot1.up
robot1.right

puts "x = #{robot1.x}, y = #{robot1.y}"
``` 

Во-первых обратите внимание на альтернативный синтаксис обращения к переменной экземпляра (`instance variable`) — через `self.` вместо `@`. Если не указать `self.` или `@`, то руби подумает, что мы хотим объявить локальную переменную в методе (даже если похожая переменная или accessor-метод уже существует).

А во-вторых, попробуйте догадаться что выведет на экран программа? Правильный ответ:

{line-numbers: false}
```ruby
x = 1, y = 3
```

Робот сделал 4 шага и его координаты равны 1 по `x` и 3 по `y`.

Для того, чтобы создать 10 таких роботов, мы просто создаем массив:

{line-numbers: false}
```ruby
arr = Array.new(10) { Robot.new }
```

А теперь применим трюк и для каждого робота из массива вызовем случайный метод:

{line-numbers: false}
```ruby
arr.each do |robot|
  m = [:right, :left, :up, :down].sample
  robot.send(m)
end
```

Трюк заключается в двух строках внутри блока. Первая строка выбирает случайный символ из массива и присваивает его переменной `m`. Вторая строка «отправляет сообщение» объекту — это просто такой способ вызвать метод (в руби могли бы назвать этот метод более понятным словом: `call` вместо `send`).

Другими словами, выше мы не только создали объекты определенного рода, но и смогли относительно легко произвести взаимодействие с целой группой объектов. Согласитесь, это намного проще, чем взаимодействовать с объектами по-одиночке.

Ради наглядного эксперимента «вообразим» на экране компьютера плоскость размером 60 на 25 и поставим каждого робота в середину. Каждую секунду будем проходить по массиву роботов, менять их положение случайным образом и перерисовывать нашу плоскость, отображая роботов звездочкой. Посмотрим, как роботы будут расползаться по экрану в случайном порядке.

Ниже приведен код такой программы с комментариями.

{line-numbers: false}
```ruby
# Класс робота
class Robot
  # Акцессоры — чтобы можно было узнать координаты снаружи
  attr_accessor :x, :y

  # Конструктор, принимает хеш. Если не задан — будет пустой хеш.
  # В хеше мы ожидаем два параметра — начальные координаты робота,
  # если не заданы, будут по-умолчанию равны нулю.
  def initialize(options={})
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right
    self.x += 1
  end

  def left
    self.x -= 1
  end

  def up
    self.y += 1
  end

  def down
    self.y -= 1
  end
end

# Класс «Командир», который будет командовать и двигать роботов
class Commander
  # Дать команду на движение робота. Метод принимает объект
  # и посылает (send) ему случайную команду.
  def move(who)
    m = [:right, :left, :up, :down].sample
    who.send(m)
  end
end

# Создать объект командира,
# командир в этом варианте программы будет один
commander = Commander.new

# Массив из 10 роботов
arr = Array.new(10) { Robot.new }

# В бесконечном цикле (для остановки программы нажмите ^C)
loop do
  # Хитрый способ очистить экран
  puts "\e[H\e[2J"

  # Рисуем воображаемую сетку. Сетка начинается от -30 до 30 по X,
  # и от 12 до -12 по Y
  (12).downto(-12) do |y|
    (-30).upto(30) do |x|
      # Проверяем, есть ли у нас в массиве робот с координатами x и y
      found = arr.any? { |robot| robot.x == x && robot.y == y }

      # Если найден, рисуем звездочку, иначе точку
      if found
        print '*'
      else
        print '.'
      end
    end

    # Просто переводим строку:
    puts
  end

  # Каждого робота двигаем в случайном направлении
  arr.each do |robot|
    commander.move(robot)
  end

  # Задержка в полсекунды
  sleep 0.5
end
```

Результат работы программы после нескольких итераций:

{line-numbers: false}
```
.............................................................
.............................................................
.............................................................
.............................*...............................
.............................................................
...........................*.......*.........................
.............................................................
...........................*.................................
............................*................................
...............................*.*...........................
............................*................................
.............................................................
.............................................................
.............................................................
........................*.......*............................
.............................................................
.............................................................
.............................................................
.............................................................
```

Демо: [https://asciinema.org/a/jMB47AhjBnxgMofSgIVzHObIH](https://asciinema.org/a/jMB47AhjBnxgMofSgIVzHObIH)

X> ## Задание: 
X> Пусть метод `initialize` принимает опцию — номер робота. Сделайте так, чтобы номер робота был еще одним параметром, который будет определять его состояние (также как и координаты). Измените методы `up` и `down` — если номер робота четный, эти методы не должны производить операции над координатами. Измените методы `left` и `right` — если номер робота нечетный, эти методы также не должны производить никаких операций над координатами. Попробуйте догадаться, что будет на экране при запуске программы.