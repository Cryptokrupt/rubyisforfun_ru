## Блоки

В Руби существует свое собственное понятие *блока кода*. Обычно, когда мы видим какой-либо код, то можем визуально разделить его на блоки или участки. Например: первые три строки отвечают за ввод информации, следующие пять строк — за вывод и т.д. Несмотря на то что мы можем называть эти участки кода блоками кода с чисто визуальной точки зрения, понятие *блок кода* в Руби имеет свое собственное значение.

Блок кода (*block*, *code block*) в Руби — это какая-то часть программы, которую мы куда-то передаем для последующего исполнения. Возникает вопрос: а зачем передавать, когда блок может исполниться вот тут сразу? На самом деле передача блока кода может иметь смысл в следующих случаях:

* код должен исполниться какое-то определенное количество раз. Скажем, мы хотим вывести «Спартак — чемпион!» 10 раз подряд. Вместо того чтобы 10 раз писать `puts`, мы можем написать `puts` в одном блоке и передать этот блок для исполнения (далее вы узнаете, как это делать). В этом случае программа может занимать одну строку вместо десяти;
* код может исполниться, а может и не исполниться при каких-либо обстоятельствах. Причем решение об этом часто принимаем не мы, а «кто-нибудь еще». Другими словами, если мы видим блок, то это еще не означает, что он будет обязательно исполнен.

Записать блок в Руби можно двумя способами:

* в несколько строк, между ключевыми словами `do` и `end`;
* в одну строку, между фигурными скобками: `{` и `}`.

Результат выполнения блока не зависит от того, как вы записали блок. Фигурные скобки предназначены для записи простых конструкций. Между `do` и `end` мы можем записать подпрограммы (блоки кода) в несколько строк. На самом деле размер блока в строках кода не ограничен. Но обычно 1 файл в языках *Ruby* и *JavaScript* не должен быть более 250 строк. Если больше, то это индикатор того, что вы что-то делаете не так.

Попробуем записать простой блок и посмотрим на результат выполнения:

{line-numbers: false}
```ruby
$ irb
> 10.times { puts 'Спартак - чемпион!' }
Спартак - чемпион!
Спартак - чемпион!
Спартак - чемпион!
Спартак - чемпион!
Спартак - чемпион!
Спартак - чемпион!
Спартак - чемпион!
Спартак - чемпион!
Спартак - чемпион!
Спартак - чемпион!
```

Давайте разберемся, что же тут произошло. Что такое `10`? С каким классом мы имеем дело? Правильно, *Integer*. Смотрим документацию по *Integer* (запрос в google «ruby Integer docs»). Далее ищем метод [`times`](https://ruby-doc.org/core-2.5.1/Integer.html#method-i-times). Из документации видно, что метод «принимает блок». На самом деле блок можно передать любому методу, даже тому, который «не принимает блок». Вопрос лишь в том, будет ли этот блок запущен. Метод `times` запускает блок.

Что же мы имеем? Мы имеем объект `10`, который знает о том, что он `10`. Существует метод *times*, который написал какой-то программист (разработчик языка), и этот метод запускает переданный ему блок 10 раз.

Запомните, что блок можно передать любому методу. Вопрос лишь в том, что будет делать этот метод с блоком. А что он будет делать — нужно смотреть в документации. Например, следующая конструкция полностью валидна:

{line-numbers: false}
```ruby
$ irb
gets { puts 'OK' }
```

Ошибки не будет, но программа не имеет смысла. `gets` не знает, что делать с блоком, и просто его проигнорирует.

Попробуем записать блок в несколько строк:

{line-numbers: false}
```ruby
10.times do
  puts "Спартак - чемпион!"
  puts "(и Динамо тоже)"
end
```

Запустите программу и посмотрите, что будет. Что происходит в программе выше:

* есть объект `10` типа *Integer*;
* мы вызываем метод `times` у этого объекта;
* мы передаем методу `times` блок кода, который состоит из двух строк.

История от автора: когда мне было около 8 лет, на советском компьютере Корвет мой отец показал мне первую программу на языке Basic:

{line-numbers: false}
```basic
10 PRINT "Рома ";
20 GOTO 10
```

Эта программа в бесконечном цикле выводила мое имя. Но из-за того, что не происходило перехода на новую строку, возникал любопытный визуальный эффект — экран наполнялся словом «Рома» и «ехал вбок». Можете попробовать сделать то же самое на языке Руби:

{line-numbers: false}
```ruby
loop do
  print 'Рома '
end
```

Программа выше выполняет операцию в бесконечном цикле. Функция `print` отличается от `puts` тем, что не переводит курсор на следующую строку.
