## Генерация случайных чисел

Про генерацию достоверно-случайных чисел написано много научных трудов. Ведь компьютер — это что-то математическое и точное, каким образом в нем может быть случайность? На более ранних компьютерах случайные числа генерировались совсем не случайно — после каждого перезапуска компьютер выдавал одну и ту же последовательность. Поэтому в игру «Морской бой» начинающие программисты научились выигрывать после нескольких попыток — было заранее известно, где компьютер расположит свои корабли.

Объяснение этому простое — нужно было где-то взять случайные данные, а взять их было негде. В современных операционных системах генератор случайных чисел учитывает множество параметров: паузы между нажатиями клавиш, движения мыши, сетевые события и так далее — вся эта информация, собранная из реального мира, помогает компьютеру генерировать случайные числа.

Но что, если этой информации недостаточно? Что, если мы только что включили компьютер, сделали несколько движений мышью и нажали несколько кнопок, и хотим получить комбинацию из миллиардов случайных чисел? Конечно, на основе полученной информации из реального мира алгоритм задает вектор, но какое количество векторов в этом случае возможно?

Кажется, что много, пока дело не доходит до реальных проблем программирования. История из жизни: на одном сайте был опубликован алгоритм перемешивания карт в игре «Онлайн Покер». Алгоритм выглядел следующим образом:

{line-numbers: false}
```
for i := 1 to 52 do begin
  r := random(51) + 1;
  swap := card[r];
  card[r] := card[i];
  card[i] := swap;
end;
```

В общем-то ничего необычного на первый взгляд, но программа содержит четыре ошибки. Первая ошибка — значение индекса на второй строке никогда не будет равно нулю. Вторая ошибка — выбранный алгоритм не гарантирует равномерного распределения карт — эту ошибку сложнее всего заметить (подробности см. в разделе [тасование Фишера-Йетса](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)). Кстати, в руби имеется встроенный [метод `shuffle` для массивов данных](https://ruby- doc.org/core- 2.5.1/Array.html#method-i-shuffle), который перемешивает правильным алгоритмом.

Но основная ошибка в том, что `random()` использует 32-битное посевное значение (seed), которое может гарантировать «всего» 2 в 32 степени (примерно 4 миллиарда) уникальных комбинаций. Тогда как настоящее количество комбинаций это факториал 52 (намного больше 2^32). Т.к. в качестве `seed` используется количество миллисекунд после полуночи, то мы имеем всего 86.4 миллиона возможных комбинаций. Получается, что после пяти карт и синхронизации времени с сервером можно предсказать все карты в реальной игре.

Пример выше лишь демонстрирует уязвимость алгоритмов для генерации случайных чисел. Если вы разрабатываете что-то важное, то стоит всерьез задуматься о «надежной» генерации случайных чисел (например, с помощью специальных устройств, которые можно подключить к компьютеру). Но для учебных целей нам подойдут встроенные функции руби — эти функции используют ядро вашей операционной системы для генерации «достаточно» случайных чисел:

{line-numbers: false}
```
$ irb
> rand(1..5)
4
> rand(1..5)
1
```

В функцию `rand` можно «хитрым образом» передать параметр, который задает диапазон (range) значений — в нашем случае от одного до пяти. При каждом вызове мы получаем случайное число из этого диапазона. Хитрость состоит в том, что мы передаем не два параметра, а один (хотя кажется, что два). Если передать два параметра, то будет ошибка:

{line-numbers: false}
```
$ irb
> rand(1, 5)
[ERROR — функция не принимает 2 значения]
```

Так что же такое `1..5` ? Давайте проверим:

{line-numbers: false}
```
$ irb
> (1..5).class
=> Range
```

Так вот оно что! Это определенный класс в языке руби, который отвечает за диапазон, и называется этот класс Range. На самом деле этот класс довольно полезный. [Документация](https://ruby-doc.org/core-2.2.0/Range.html) по этому классу выдает много интересного, но давайте для начала убедимся, что это никакая не магия, и этот объект можно инициализировать, как и любую другую переменную:

{line-numbers: false}
```
$ irb
> x = 1..5
=> 1..5
> rand(x)
=> 4
```

Теперь понятно, что «rand» принимает один параметр. Попробуем скомбинировать `rand` и `sleep`:

{line-numbers: false}
```
$ irb
> sleep rand(1..5)
```

Программа будет ждать какое-то случайное количество секунд, от 1 до 5. Кстати, передать параметр в любой метод в языке руби можно как со скобками, так и без. Вот эти конструкции будут идентичны:

{line-numbers: false}
```
$ irb
> sleep rand(1..5)
> sleep rand 1..5
> sleep(rand(1..5))
```

Последняя строка наиболее наглядно демонстрирует, что желает получить программист от языка руби:

* сначала выполняется конструкция `1..5`, с помощью которой создается объект Range; 
* затем вычисляется случайное значение в диапазоне `rand(...)`; 
* затем ожидаем определенное количество секунд — т.е. то количество секунд, которое вернула функция `rand`.

Использовать скобки или нет — личное предпочтение программиста. Чтобы не возникало путаницы, статические анализаторы кода (напр. Rubocop) выдают предупреждения, если ваш стиль сильно отличается от общепринятого стандарта.

Отдельно хочется отметить возможность вычислять случайные дробные значения:

{line-numbers: false}
```
$ irb
> rand(0.03..0.09)
=> 0.03920647825951599
> rand(0.03..0.09)
=> 0.06772359081051581
```

X> ## Задание 1 
X> Посмотрите [документацию по классу Range](https://ruby-doc.org/core-2.5.1/Range.html).


X> ## Задание 2 
X> Напишите программу, которая будет выводить случайное число от 500 до 510.


X> ## Задание 3 
X> Напишите программу, которая будет выводить случайное число с дробью от 0 до 1. Например, 0.54321 или 0.123456


X> ## Задание 4 
X> Напишите программу, которая будет выводить случайное число с дробью от 2 до 4.

...конец абзаца. 
{line-numbers: false}
~~~
~~~
Этот пустой блок кода имеет длину 3 строки, поэтому он добавляет к выходным данным три пустые строки кода.




