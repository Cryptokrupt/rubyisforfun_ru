## Структура данных «Хеш» (Hash)

Хеш (также говорят хеш-таблица, `hashtable`, `hash, map`, `dictionary`, в языке JavaScript часто называют «объект») и массив — две основные структуры данных, которые часто используются вместе. Хеш и массивы — разные структуры данных, но они преследуют одну цель — хранение и извлечение данных. Различаются лишь способы сохранения и извлечения.

Что такое массив, как он хранит данные и как мы извлекаем данные из массива? Представьте, что у маленького ребенка много разных игрушек. Мама положила на полку все игрушки и каждому месту на полке присвоила порядковый номер. Чтобы найти игрушку в массиве, нам нужно просмотреть всю полку. Если полка с игрушками очень длинная, то это займет какое-то время. Но зато если мы точно знаем номер игрушки, мы можем найти ее моментально.

Хеш напоминает волшебную корзину. В ней нет никакого порядка и мы не знаем как она устроена (знаем конечно, но многие программисты даже об этом не задумываются). В эту корзину можно положить какой угодно объект и сказать ей название: «волшебная корзина, это мяч». Потом можно извлечь из этой корзины любой объект по имени: «волшебная корзина, дай мне эту вещь, про которую я говорил, что она называется мяч». Важно что мы складываем объекты, указывая имя и извлекаем по имени (имя объекта называется ключом). Причем, извлечение происходит моментально — таким образом работает волшебная корзина.

Как же работает волшебная корзина, почему в случае поиска элемента в массиве нужно просматривать весь массив, а в случае поиска какого-либо объекта в хеше поиск происходит моментально? Секрет в организации. На самом деле в большой корзине много маленьких корзин (они так и называются `buckets`). Если упростить, то все маленькие корзины внутри тоже пронумерованы, а объекты складываются туда по какому-либо признаку (скажем, по цвету). Если объектов много, то и маленьких корзин должно быть больше.

Если хеши так хороши, то почему бы их не использовать всегда?

Во-первых, эта структура данных не гарантирует порядок. Если мы добавляем данные в массив с помощью `push`, то мы точно знаем, какой элемент был добавлен сначала, какой после. В хеше нет никакого порядка, как только мы записали туда значение, нет возможности сказать когда именно оно туда попало: раньше или позже остальных.  

Примечание: несмотря на то, что структура данных «хеш» не гарантирует порядок, в руби порядок гарантируется (однако, авторы бы не рекомендовали на него надеяться). Вот что говорит [официальная документация](https://ruby-doc.org/core-2.5.1/Hash.html):

> Hashes enumerate their values **in the order** that the corresponding keys were inserted.

Но т.к. любой веб-разработчик должен хотя бы на минимальном уровне знать JavaScript, то посмотрим что говорит по этому поводу документация по JS:

> An object is a member of the type Object. It is an **unordered** collection of properties each of which contains a primitive value, object, or function

Однако, в новой версии языка JavaScript (ES6 и выше) класс *Map* (альтернативная реализация хеша `{}`) будет возвращать значения из хеша в порядке добавления. Правило хорошего тона: при использовании хешей не надейтесь на порядок.

А во-вторых, для каждой структуры данных существует такое понятие как «худшее время исполнения операции»: при неблагоприятных обстоятельствах (скажем, все игрушки оказались одного цвета и попали в одну и ту же внутреннюю маленькую корзину) операции доступа, вставки и извлечения для хеша работают за линейное время (`linear time`, O(N)). Другими словами, в худшем случае код для извлечения какого-либо элемента из хеша будет перебирать все элементы. А код для извлечения элемента из массива по индексу в худшем случае всегда занимает константное время (`constant time`, O(1)) — т.е. грубо говоря — всегда одно обращение, без прохода по массиву.

Конечно, на практике худшие случаи встречаются не часто, и основная причина по которой программисты используют хеши — удобство для человека. Гораздо проще сказать «извлечь мяч», чем «извлечь объект по индексу 148».

Объявить хеш в вашей программе очень просто, достаточно использовать фигурные скобки (квадратные скобки используются для массива):

{line-numbers: false}
```
$ pry
> obj = {}
...
> obj.class
Hash < Object
```

Имейте в виду, что использовать переменную с названием `hash` нельзя, т.к. это зарезервированное ключевое слово языка (но вы можете ввести его в REPL и посмотреть что произойдет). Поэтому обычно авторы используют `obj` (от слова `object`) или «hh» (двойное hh говорит о том, что это что-то большее, чем просто переменная).

Говорят, что хеш это `key-value storage` (хранилище типа ключ-значение), где каждому ключу соответствует значение. Например, ключ — «мяч» (строка), а значение — сам физический объект «мяч». Часто хеш называют словарем (`dictionary`). Что отчасти тоже верно, ведь словарь слов это прекрасный пример хеша. Каждому ключу (слово) соответствует значение (описание слова и/или перевод). В языке Java хеш раньше тоже назывался «словарем», но с седьмой версии это понятие вышло из употребление и словарь начали называть [`map`](https://docs.oracle.com/javase/7/docs/api/java/util/Dictionary.html).

Ключом и значением в хеше может быть любой объект, но чаще всего ключ это строка (или символ), а значение… Значение это действительно объект, сложно предсказать что это будет. Это может быть строка, символ, массив, число, другой хеш. Поэтому когда в руби определяют хеш (записывают его в программе), в уме обычно заранее знают какого типа значение (`value`) будет в нем содержаться.

Например, давайте условимся, что ключом в хеше будет какой-либо символ, а значением — число. Запишем в наш хеш вес различных мячей в граммах:

{line-numbers: false}
```
obj = {}
obj[:soccer_ball] = 410
obj[:tennis_ball] = 58
obj[:golf_ball] = 45 
```

Если записать эту программу в REPL и вывести объект на экран (написав `obj`), то мы увидим следующую запись:

{line-numbers: false}
```
{
    :soccer_ball => 410,
    :tennis_ball => 58,
    :golf_ball => 45
}
```

Эта запись полностью валидна с точки зрения языка Руби, и мы могли бы инициализировать наш хеш без записи значений (без использования операции присвоения):

{line-numbers: false}
```
obj = {
    :soccer_ball => 410,
    :tennis_ball => 58,
    :golf_ball => 45
}
```

Оператор `=>` в руби называется `hash rocket` (в JavaScript `fat arrow`, но имеет другое значение). Однако, запись с помощью `hash rocket` считается устаревшей. Правильнее было бы записать так:

{line-numbers: false}
```
obj = {
  soccer_ball: 410,
  tennis_ball: 58,
  golf_ball: 45
}
```

Обратите внимание, что несмотря на то, что запись выглядит иначе, если мы напишем в REPL `obj`, то мы получим тот же вывод, что и выше. Другими словами, ключи (`:soccer_ball`, `:tennis_ball`, `:golf_ball`) в этом случае являются типами *Symbol*.

Для извлечения значения (`value`) из хеша можно воспользоваться следующей конструкцией:

{line-numbers: false}
```ruby
puts 'Вес мяча для гольфа:'
puts obj[:golf_ball]
```

Обращение к хешу очень похоже на обращение к массиву. В случае с массивом — мы обращаемся по индексу, в случае с хешем — по ключу.

Заметьте, что символы это не то же самое, что и строки. Если мы определяем хеш следующим образом:

{line-numbers: false}
```ruby
obj = {}
obj[:golf_ball] = 45
obj['golf_ball'] = 45
```

То в хеш будет добавлено две пары ключ-значение (первый ключ типа *Symbol*, второй типа *String*:

{line-numbers: false}
```ruby
{ :golf_ball => 45, "golf_ball" => 45 }
```

X> ## Задание
X> Используя инициализированный хеш из примера ниже, напишите код, который адаптирует этот хеш для условий на Луне. Известно, что вес на луне в 6 раз меньше, чем вес на Земле:

{line-numbers: false}
```ruby
obj = {
  soccer_ball: 410,
  tennis_ball: 58,
  golf_ball: 45
}
```

X> ## Задание
X> «Лунный магазин». Используя хеш с новым весом из предыдущего задания напишите программу, которая для каждого типа спрашивает пользователя какое количество мячей пользователь хотел бы купить в магазине (ввод числа из консоли). В конце программа выдает общий вес всех товаров в корзине. Для сравнения программа должна также выдавать общий вес всех товаров, если бы они находились на Земле.

