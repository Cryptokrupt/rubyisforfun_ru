## Здравствуйте, я ваш REPL

В случае с `1+1` выше наш интерпретатор выполняет два действия: read (прочитать), evaluate (выполнить). Так как не было третьего действия `print` (puts в нашем случае), то не было и результата на экране. То есть чтобы мы видели результат, надо выполнить:

* read (R);
* evaluate (E);
* print (P).

Хорошо бы еще и не запускать ruby каждый раз, чтобы программа в бесконечном цикле (loop — L) спрашивала нас «*что хотите выполнить?*», т.е. сразу принимала бы ввод без лишних разговоров.

Из начальных букв у нас получилось REPL — read evaluate print loop. То есть REPL — это такая программа, которая сначала читает, потом исполняет, потом печатает результат и затем начинает все сначала. Это понятие широко известно и используется не только в Руби. А в Руби REPL-программа называется irb (interactive ruby).

Попробуйте ввести irb и посмотрите, что произойдет:

{line-numbers: false}
```
$ irb
2.5.1 :001 >
``` 

Непонятные цифры вначале — это версия Руби. В нашем случае 2.5.1 (то же самое покажет команда `ruby -v`). `001` — это номер строки. То есть если REPL уже содержит «P» (print), то можно вводить `1+1` без puts.

X> ## Задание
X> Посчитайте количество секунд в сутках, не выводя результат на экран с помощью `puts`.

Принцип наименьшего сюрприза говорит нам о том, что выход из REPL должен быть командой `exit`. Вводим `exit` — получилось!

Тут хочется заметить, что авторы редко используют именно irb в роли REPL. Есть лучшая альтернатива под названием [Pry](http://pry.github.io/). Он выполняет ту же самую функцию, но имеет больше настроек. Этот инструмент рассматривается дальше в нашей книге.
